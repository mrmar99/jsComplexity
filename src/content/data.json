{
  "en": {
    "Array": {
      "Array/Array.from()": {
        "content": "Hi :) It's `Array.from`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.from",
        "title": "Array.from()",
        "slug": "Array/Array.from()"
      },
      "Array/Array.fromAsync()": {
        "content": "Hi :) It's `Array.fromAsync`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/proposal-array-from-async/#sec-array.fromAsync",
        "title": "Array.fromAsync()",
        "slug": "Array/Array.fromAsync()"
      },
      "Array/Array.isArray()": {
        "content": "Hi :) It's `Array.isArray`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.isarray",
        "title": "Array.isArray()",
        "slug": "Array/Array.isArray()"
      },
      "Array/Array.of()": {
        "content": "Hi :) It's `Array.of`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.of",
        "title": "Array.of()",
        "slug": "Array/Array.of()"
      },
      "Array/at()": {
        "content": "The **`at()`** method of Array instances takes an integer value and returns the item at that index, allowing for positive and negative integers. Negative integers count back from the last item in the array.\r\n",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.at",
        "title": "at()",
        "slug": "Array/at()"
      },
      "Array/concat()": {
        "content": "Hi :) It's `at`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n + m * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n + m * k)",
          "color": "orange"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.concat",
        "title": "concat()",
        "slug": "Array/concat()"
      },
      "Array/copyWithin()": {
        "content": "en `copyWithin`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.copywithin",
        "title": "copyWithin()",
        "slug": "Array/copyWithin()"
      },
      "Array/entries()": {
        "content": "en `entries`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.entries",
        "title": "entries()",
        "slug": "Array/entries()"
      },
      "Array/every()": {
        "content": "`every`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.every",
        "title": "every()",
        "slug": "Array/every()"
      },
      "Array/fill()": {
        "content": "`fill`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.fill",
        "title": "fill()",
        "slug": "Array/fill()"
      },
      "Array/filter()": {
        "content": "`filter`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.filter",
        "title": "filter()",
        "slug": "Array/filter()"
      },
      "Array/find()": {
        "content": "`find`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find",
        "title": "find()",
        "slug": "Array/find()"
      },
      "Array/findIndex()": {
        "content": "`findIndex`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findindex",
        "title": "findIndex()",
        "slug": "Array/findIndex()"
      },
      "Array/findLast()": {
        "content": "`findLast`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findlast",
        "title": "findLast()",
        "slug": "Array/findLast()"
      },
      "Array/findLastIndex()": {
        "content": "Hi :) It's `findLastIndex`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findlastindex",
        "title": "findLastIndex()",
        "slug": "Array/findLastIndex()"
      },
      "Array/flat()": {
        "content": "`flat`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.flat",
        "title": "flat()",
        "slug": "Array/flat()"
      },
      "Array/flatMap()": {
        "content": "`flatMap`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.flatmap",
        "title": "flatMap()",
        "slug": "Array/flatMap()"
      },
      "Array/forEach()": {
        "content": "`forEach`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.foreach",
        "title": "forEach()",
        "slug": "Array/forEach()"
      },
      "Array/includes()": {
        "content": "`includes`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.includes",
        "title": "includes()",
        "slug": "Array/includes()"
      },
      "Array/indexOf()": {
        "content": "`indexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.indexof",
        "title": "indexOf()",
        "slug": "Array/indexOf()"
      },
      "Array/join()": {
        "content": "Hi :) It's  `join`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.join",
        "title": "join()",
        "slug": "Array/join()"
      },
      "Array/keys()": {
        "content": "`keys`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.keys",
        "title": "keys()",
        "slug": "Array/keys()"
      },
      "Array/lastIndexOf()": {
        "content": "Hi :) It's  `lastIndexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof",
        "title": "lastIndexOf()",
        "slug": "Array/lastIndexOf()"
      },
      "Array/map()": {
        "content": "`map`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map",
        "title": "map()",
        "slug": "Array/map()"
      },
      "Array/pop()": {
        "content": "`pop`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.pop",
        "title": "pop()",
        "slug": "Array/pop()"
      },
      "Array/push()": {
        "content": "`push`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push",
        "title": "push()",
        "slug": "Array/push()"
      },
      "Array/reduce()": {
        "content": "`reduce`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(m)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce",
        "title": "reduce()",
        "slug": "Array/reduce()"
      },
      "Array/reduceRight()": {
        "content": "Hi :) It's `reduceRight`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(m)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduceright",
        "title": "reduceRight()",
        "slug": "Array/reduceRight()"
      },
      "Array/reverse()": {
        "content": "`reverse`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reverse",
        "title": "reverse()",
        "slug": "Array/reverse()"
      },
      "Array/shift()": {
        "content": "`shift`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.shift",
        "title": "shift()",
        "slug": "Array/shift()"
      },
      "Array/slice()": {
        "content": "`slice`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.slice",
        "title": "slice()",
        "slug": "Array/slice()"
      },
      "Array/some()": {
        "content": "`some`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.some",
        "title": "some()",
        "slug": "Array/some()"
      },
      "Array/sort()": {
        "content": "Hi :) It's `sort`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "average": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n²)",
            "color": "red"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.sort",
        "title": "sort()",
        "slug": "Array/sort()"
      },
      "Array/splice()": {
        "content": "`splice`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(k)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.splice",
        "title": "splice()",
        "slug": "Array/splice()"
      },
      "Array/toLocaleString()": {
        "content": "Hi :) It's `toLocaleString`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tolocalestring",
        "title": "toLocaleString()",
        "slug": "Array/toLocaleString()"
      },
      "Array/toReversed()": {
        "content": "`toReversed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.toreversed",
        "title": "toReversed()",
        "slug": "Array/toReversed()"
      },
      "Array/toSorted()": {
        "content": "`toSorted`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "average": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n²)",
            "color": "red"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tosorted",
        "title": "toSorted()",
        "slug": "Array/toSorted()"
      },
      "Array/toSpliced()": {
        "content": "`toSpliced`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n - k)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tospliced",
        "title": "toSpliced()",
        "slug": "Array/toSpliced()"
      },
      "Array/toString()": {
        "content": "`toString`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tostring",
        "title": "toString()",
        "slug": "Array/toString()"
      },
      "Array/unshift()": {
        "content": "`unshift`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.unshift",
        "title": "unshift()",
        "slug": "Array/unshift()"
      },
      "Array/values()": {
        "content": "`values`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.values",
        "title": "values()",
        "slug": "Array/values()"
      },
      "Array/with()": {
        "content": "`with`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.with",
        "title": "with()",
        "slug": "Array/with()"
      }
    },
    "ECMAScript": {
      "ECMAScript/ToString()": {
        "content": "",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.from",
        "title": "ToString()",
        "slug": "ECMAScript/ToString()"
      }
    },
    "String": {
      "String/anchor()": {
        "content": "`anchor`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "anchor()",
        "slug": "String/anchor()"
      },
      "String/at()": {
        "content": "`at`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "at()",
        "slug": "String/at()"
      },
      "String/big()": {
        "content": "`big`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "big()",
        "slug": "String/big()"
      },
      "String/blink()": {
        "content": "`blink`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "blink()",
        "slug": "String/blink()"
      },
      "String/bold()": {
        "content": "`bold`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "bold()",
        "slug": "String/bold()"
      },
      "String/charAt()": {
        "content": "`charAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "charAt()",
        "slug": "String/charAt()"
      },
      "String/charCodeAt()": {
        "content": "`charCodeAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "charCodeAt()",
        "slug": "String/charCodeAt()"
      },
      "String/codePointAt()": {
        "content": "`codePointAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "codePointAt()",
        "slug": "String/codePointAt()"
      },
      "String/concat()": {
        "content": "`concat`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "concat()",
        "slug": "String/concat()"
      },
      "String/endsWith()": {
        "content": "`endsWith`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "endsWith()",
        "slug": "String/endsWith()"
      },
      "String/fixed()": {
        "content": "`fixed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fixed()",
        "slug": "String/fixed()"
      },
      "String/fontcolor()": {
        "content": "`fontcolor`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fontcolor()",
        "slug": "String/fontcolor()"
      },
      "String/fontsize()": {
        "content": "`fontsize`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fontsize()",
        "slug": "String/fontsize()"
      },
      "String/includes()": {
        "content": "`includes`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "includes()",
        "slug": "String/includes()"
      },
      "String/indexOf()": {
        "content": "`indexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "indexOf()",
        "slug": "String/indexOf()"
      },
      "String/isWellFormed()": {
        "content": "`isWellFormed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "isWellFormed()",
        "slug": "String/isWellFormed()"
      },
      "String/italics()": {
        "content": "`italics`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "italics()",
        "slug": "String/italics()"
      },
      "String/lastIndexOf()": {
        "content": "`lastIndexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "lastIndexOf()",
        "slug": "String/lastIndexOf()"
      },
      "String/link()": {
        "content": "`link`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "link()",
        "slug": "String/link()"
      },
      "String/localeCompare()": {
        "content": "`localeCompare`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "localeCompare()",
        "slug": "String/localeCompare()"
      },
      "String/match()": {
        "content": "`match`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "match()",
        "slug": "String/match()"
      },
      "String/matchAll()": {
        "content": "`matchAll`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "matchAll()",
        "slug": "String/matchAll()"
      },
      "String/normalize()": {
        "content": "`normalize`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "normalize()",
        "slug": "String/normalize()"
      },
      "String/padEnd()": {
        "content": "`padEnd`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "padEnd()",
        "slug": "String/padEnd()"
      },
      "String/padStart()": {
        "content": "`padStart`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "padStart()",
        "slug": "String/padStart()"
      },
      "String/repeat()": {
        "content": "`repeat`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "repeat()",
        "slug": "String/repeat()"
      },
      "String/replace()": {
        "content": "`replace`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "replace()",
        "slug": "String/replace()"
      },
      "String/replaceAll()": {
        "content": "`replaceAll`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "replaceAll()",
        "slug": "String/replaceAll()"
      },
      "String/search()": {
        "content": "`search`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "search()",
        "slug": "String/search()"
      },
      "String/slice()": {
        "content": "Hi :) It's `slice`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "slice()",
        "slug": "String/slice()"
      },
      "String/small()": {
        "content": "`small`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "small()",
        "slug": "String/small()"
      },
      "String/split()": {
        "content": "Hi :) It's `split`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "split()",
        "slug": "String/split()"
      },
      "String/startsWith()": {
        "content": "`startsWith`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "startsWith()",
        "slug": "String/startsWith()"
      },
      "String/strike()": {
        "content": "`strike`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "strike()",
        "slug": "String/strike()"
      },
      "String/String.fromCharCode()": {
        "content": "`String.fromCharCode`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.fromCharCode()",
        "slug": "String/String.fromCharCode()"
      },
      "String/String.fromCodePoint()": {
        "content": "`String.fromCodePoint`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.fromCodePoint()",
        "slug": "String/String.fromCodePoint()"
      },
      "String/String.raw()": {
        "content": "`String.raw`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.raw()",
        "slug": "String/String.raw()"
      },
      "String/sub()": {
        "content": "`sub`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "sub()",
        "slug": "String/sub()"
      },
      "String/substr()": {
        "content": "`substr`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "substr()",
        "slug": "String/substr()"
      },
      "String/substring()": {
        "content": "`substring`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "substring()",
        "slug": "String/substring()"
      },
      "String/sup()": {
        "content": "`sup`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "sup()",
        "slug": "String/sup()"
      },
      "String/toLocaleLowerCase()": {
        "content": "`toLocaleLowerCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLocaleLowerCase()",
        "slug": "String/toLocaleLowerCase()"
      },
      "String/toLocaleUpperCase()": {
        "content": "`toLocaleUpperCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLocaleUpperCase()",
        "slug": "String/toLocaleUpperCase()"
      },
      "String/toLowerCase()": {
        "content": "`toLowerCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLowerCase()",
        "slug": "String/toLowerCase()"
      },
      "String/toString()": {
        "content": "`toString`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toString()",
        "slug": "String/toString()"
      },
      "String/toUpperCase()": {
        "content": "`toUpperCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toUpperCase()",
        "slug": "String/toUpperCase()"
      },
      "String/toWellFormed()": {
        "content": "`toWellFormed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toWellFormed()",
        "slug": "String/toWellFormed()"
      },
      "String/trim()": {
        "content": "`trim`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trim()",
        "slug": "String/trim()"
      },
      "String/trimEnd()": {
        "content": "`trimEnd`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trimEnd()",
        "slug": "String/trimEnd()"
      },
      "String/trimStart()": {
        "content": "`trimStart`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trimStart()",
        "slug": "String/trimStart()"
      },
      "String/valueOf": {
        "content": "`valueOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "valueOf",
        "slug": "String/valueOf"
      }
    }
  },
  "ru": {
    "Array": {
      "Array/Array.from()": {
        "content": "Метод `Array.from()` создаёт новый экземпляр `Array` из массивоподобного или итерируемого объекта.\r\n\r\n##### Использование\r\n\r\n```js\r\nconsole.log(Array.from('foo'));\r\n// [\"f\", \"o\", \"o\"]\r\n\r\nconsole.log(Array.from([1, 2, 3], (x) => x + x));\r\n// [2, 4, 6]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = items.length\r\n// k = mapfn\r\n\r\n// this = Array (Array.from(...)) / someArray (someArray.from(...))\r\nArray.from = function(items, mapfn, thisArg) {\r\n  // 1. Определяем C как текущее значение this\r\n  let C = this;\r\n\r\n  // 2. Если mapfn не определен, устанавливаем mapping в false\r\n  // 3. Иначе, если mapfn не является вызываемой функцией, \r\n  // выбрасываем исключение TypeError\r\n  // и устанавливаем mapping в true\r\n  let mapping;\r\n  if (mapfn === undefined) {\r\n    mapping = false;\r\n  } else {\r\n    if (!IsCallable(mapfn)) {\r\n      throw new TypeError();\r\n    }\r\n    mapping = true;\r\n  }\r\n\r\n  // 4. Получаем метод @@iterator из items\r\n  let usingIterator = GetMethod(items, Symbol.iterator);\r\n\r\n  // 5. Если usingIterator определен, выполняем следующие шаги\r\n  if (usingIterator !== undefined) {\r\n    // a. Если C является конструктором, устанавливаем A как новый объект, созданный с помощью C\r\n    // b. Иначе устанавливаем A как новый массив с длиной 0\r\n    let A = (IsConstructor(C)) ? Construct(C) : ArrayCreate(0);\r\n\r\n    // c. Получаем итератор для items\r\n    let iteratorRecord = GetIteratorFromMethod(items, usingIterator);\r\n\r\n    // d. Устанавливаем k в 0\r\n    let k = 0;\r\n\r\n    // e. Повторяем\r\n    while (true) {\r\n      // i. Если k >= 2^53 - 1, выбрасываем исключение TypeError\r\n      // и закрываем итератор\r\n      if (k >= 2**53 - 1) {\r\n        let error = ThrowCompletion(new TypeError());\r\n        return IteratorClose(iteratorRecord, error);\r\n      }\r\n\r\n      // ii. Переводим k в строку Pk\r\n      let Pk = ToString(𝔽(k));\r\n\r\n      // iii. Получаем следующее значение из итератора\r\n      let next = IteratorStepValue(iteratorRecord);\r\n\r\n      // iv. Если next равно DONE, устанавливаем длину A в k и возвращаем A\r\n      if (next === DONE) {\r\n        Set(A, \"length\", 𝔽(k), true);\r\n        return A;\r\n      }\r\n\r\n      // v. Если mapping равно true, вызываем mapfn с аргументами next и 𝔽(k),\r\n      //    присваиваем результат переменной mappedValue\r\n      let mappedValue = (mapping) ? Call(mapfn, thisArg, [next, 𝔽(k)]) : next;\r\n\r\n      // vi. Устанавливаем Pk в mappedValue в объекте A\r\n      let defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\r\n      // vii. Если возникло исключение при выполнении defineStatus, закрываем итератор\r\n      IfAbruptCloseIterator(defineStatus, iteratorRecord);\r\n\r\n      // viii. Увеличиваем k на 1\r\n      k = k + 1;\r\n    }\r\n  }\r\n\r\n  // 6. Примечание: items не является итерируемым, поэтому предполагаем, что это объект похожий на массив\r\n\r\n  // 7. Преобразуем items в объект arrayLike\r\n  let arrayLike = ToObject(items);\r\n\r\n  // 8. Получаем длину arrayLike\r\n  let len = LengthOfArrayLike(arrayLike);\r\n\r\n  // 9. Если C является конструктором, устанавливаем A как новый объект, созданный с помощью C\r\n  // 10. Иначе устанавливаем A как новый массив с длиной len\r\n  let A = (IsConstructor(C)) ? Construct(C, [𝔽(len)]) : ArrayCreate(len);\r\n\r\n  // 11. Устанавливаем k в 0\r\n  let k = 0;\r\n\r\n  // 12. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Переводим k в строку Pk\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Получаем значение kValue из arrayLike по ключу Pk\r\n    let kValue = Get(arrayLike, Pk);\r\n\r\n    // c. Если mapping равно true, вызываем mapfn с аргументами kValue и 𝔽(k),\r\n    //    присваиваем результат переменной mappedValue\r\n    let mappedValue = (mapping) ? Call(mapfn, thisArg, [kValue, 𝔽(k)]) : kValue;\r\n\r\n    // d. Устанавливаем Pk в mappedValue в объекте A\r\n    CreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\r\n    // e. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 13. Устанавливаем длину A в len\r\n  Set(A, \"length\", 𝔽(len), true);\r\n\r\n  // 14. Возвращаем A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let C be the this value.\r\n2. If mapfn is undefined, then\r\n   a. Let mapping be false.\r\n3. Else,\r\n   a. If IsCallable(mapfn) is false, throw a TypeError exception.\r\n   b. Let mapping be true.\r\n4. Let usingIterator be ? GetMethod(items, @@iterator).\r\n5. If usingIterator is not undefined, then\r\n   a. If IsConstructor(C) is true, then\r\n      i. Let A be ? Construct(C).\r\n   b. Else,\r\n      i. Let A be ! ArrayCreate(0).\r\n   c. Let iteratorRecord be ? GetIteratorFromMethod(items, usingIterator).\r\n   d. Let k be 0.\r\n   e. Repeat,\r\n      i. If k ≥ 2**53 - 1, then\r\n         1. Let error be ThrowCompletion(a newly created TypeError object).\r\n         2. Return ? IteratorClose(iteratorRecord, error).\r\n      ii. Let Pk be ! ToString(𝔽(k)).\r\n      iii. Let next be ? IteratorStepValue(iteratorRecord).\r\n      iv. If next is DONE, then\r\n         1. Perform ? Set(A, \"length\", 𝔽(k), true).\r\n         2. Return A.\r\n      v. If mapping is true, then\r\n         1. Let mappedValue be Completion(Call(mapfn, thisArg, « next, 𝔽(k) »)).\r\n         2. IfAbruptCloseIterator(mappedValue, iteratorRecord).\r\n      vi. Else,\r\n         1. Let mappedValue be next.\r\n      vii. Let defineStatus be Completion(CreateDataPropertyOrThrow(A, Pk, mappedValue)).\r\n      viii. IfAbruptCloseIterator(defineStatus, iteratorRecord).\r\n      ix. Set k to k + 1.\r\n6. NOTE: items is not an Iterable so assume it is an array-like object.\r\n7. Let arrayLike be ! ToObject(items).\r\n8. Let len be ? LengthOfArrayLike(arrayLike).\r\n9. If IsConstructor(C) is true, then\r\n   a. Let A be ? Construct(C, « 𝔽(len) »).\r\n10. Else,\r\n   a. Let A be ? ArrayCreate(len).\r\n11. Let k be 0.\r\n12. Repeat, while k < len,\r\n   a. Let Pk be ! ToString(𝔽(k)).\r\n   b. Let kValue be ? Get(arrayLike, Pk).\r\n   c. If mapping is true, then\r\n      i. Let mappedValue be ? Call(mapfn, thisArg, « kValue, 𝔽(k) »).\r\n   d. Else,\r\n      i. Let mappedValue be kValue.\r\n   e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n   f. Set k to k + 1.\r\n13. Perform ? Set(A, \"length\", 𝔽(len), true).\r\n14. Return A.\r\n```\r\n",
        "parsedMethods": [
          "Array()",
          "IsCallable()",
          "TypeError()",
          "GetMethod()",
          "IsConstructor()",
          "Construct()",
          "ArrayCreate()",
          "GetIteratorFromMethod()",
          "ThrowCompletion()",
          "IteratorClose()",
          "ToString()",
          "IteratorStepValue()",
          "Set()",
          "Call()",
          "CreateDataPropertyOrThrow()",
          "IfAbruptCloseIterator()",
          "ToObject()",
          "LengthOfArrayLike()",
          "Get()",
          "Completion()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.from",
        "title": "Array.from()",
        "slug": "Array/Array.from()"
      },
      "Array/Array.fromAsync()": {
        "content": "Метод `Array.fromAsync()` создаёт новый экземпляр `Array` из асинхронно итерируемого, итерируемого или массивоподобного объекта.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst fetchData = async (url) => {\r\n  try {\r\n    const response = await fetch(url);\r\n    const json = await response.json();\r\n    return json;\r\n  } catch (e) {\r\n    throw e;\r\n  }\r\n};\r\n\r\n(async () => {\r\n  const url = 'https://jsonplaceholder.typicode.com/todos';\r\n\r\n  try {\r\n    const todos = await fetchData(url);\r\n\r\n    function mapFunction(todo) {\r\n      return { \r\n        id: todo.id,\r\n        title: todo.title,\r\n      };\r\n    }\r\n\r\n    const processedData = await Array.fromAsync(todos, mapFunction);\r\n\r\n    console.log(processedData);\r\n    /*\r\n    [\r\n      { id: 1, title: \"delectus aut autem\" },\r\n      { id: 2, title: \"quis ut nam facilis et officia qui\" },\r\n      // ...\r\n    ]\r\n    */\r\n  } catch (e) {\r\n    console.log(e);\r\n  }\r\n})();\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = asyncItems.length\r\n// k = mapfn\r\n\r\n// this = asyncItems\r\nArray.fromAsync = function(asyncItems, mapfn, thisArg) {\r\n  // 1. Определяем C как текущее значение this\r\n  let C = this;\r\n\r\n  // 2. Создаем promiseCapability, используя \r\n  // внутренний конструктор NewPromiseCapability\r\n  let promiseCapability = NewPromiseCapability(%Promise%);\r\n\r\n  // 3. Создаем абстрактное замыкание fromAsyncClosure, захватывающее C, mapfn и thisArg\r\n  let fromAsyncClosure = function () {\r\n    // 3a. Если mapfn не определено, устанавливаем mapping в false\r\n    // 3b. Иначе,\r\n    // i. Если mapfn не является вызываемой функцией, выбрасываем исключение TypeError\r\n    // ii. Устанавливаем mapping в true\r\n    let mapping = (mapfn === undefined) ? false : true;\r\n\r\n    // 3c. Получаем метод @@asyncIterator объекта asyncItems\r\n    let usingAsyncIterator = GetMethod(asyncItems, @@asyncIterator);\r\n\r\n    // 3d. Если метод @@asyncIterator не определен, получаем метод @@iterator\r\n    // 3e. Создаем переменную iteratorRecord и устанавливаем ее в undefined\r\n    let usingSyncIterator = (usingAsyncIterator === undefined) ? GetMethod(asyncItems, @@iterator) : undefined;\r\n    let iteratorRecord;\r\n\r\n    // 3f. Если метод @@asyncIterator определен, получаем итератор с использованием ASYNC\r\n    // 3g. Иначе, если метод @@iterator определен, создаем асинхронный итератор с использованием SYNC\r\n    if (usingAsyncIterator !== undefined) {\r\n      iteratorRecord = GetIterator(asyncItems, ASYNC, usingAsyncIterator);\r\n    } else if (usingSyncIterator !== undefined) {\r\n      iteratorRecord = CreateAsyncFromSyncIterator(GetIterator(asyncItems, SYNC, usingSyncIterator));\r\n    }\r\n\r\n    // 3h. Если iteratorRecord определен, выполняем шаги для обработки массивоподобного объекта\r\n    if (iteratorRecord !== undefined) {\r\n      // 3h(i). Если C является конструктором, создаем новый массив A\r\n      // 3h(ii). Иначе, создаем новый массив A с длиной 0\r\n      let A = (IsConstructor(C) === true) ? Construct(C) : ArrayCreate(0);\r\n\r\n      // 3h(iii). Устанавливаем k в 0\r\n      let k = 0;\r\n\r\n      // 3h(iv). Повторяем следующее:\r\n      while (true) {\r\n        // 1. Если k >= 2**53 - 1, выбрасываем исключение TypeError\r\n        if (k >= 2**53 - 1) {\r\n          let error = ThrowCompletion(new TypeError());\r\n          return AsyncIteratorClose(iteratorRecord, error);\r\n        }\r\n\r\n        // 2. Получаем строковое представление числа k\r\n        let Pk = ToString(𝔽(k));\r\n\r\n        // 3. Вызываем метод [[NextMethod]] итератора и получаем результат\r\n        let nextResult = Call(iteratorRecord.[[NextMethod]], iteratorRecord.[[Iterator]]);\r\n\r\n        // 4. Ожидаем результат, так как итератор может возвращать Promise\r\n        nextResult = Await(nextResult);\r\n\r\n        // 5. Если результат не является объектом, \r\n        // выбрасываем исключение TypeError\r\n        if (!IsObject(nextResult)) {\r\n          throw new TypeError();\r\n        }\r\n\r\n        // 6. Проверяем, завершен ли итератор\r\n        let done = IteratorComplete(nextResult);\r\n\r\n        if (done === true) {\r\n          // 7. Если завершен, устанавливаем \r\n          // длину массива A в k и возвращаем A\r\n          Set(A, \"length\", 𝔽(k), true);\r\n          return { [[Type]]: RETURN, [[Value]]: A, [[Target]]: EMPTY };\r\n        }\r\n\r\n        // 8. Получаем значение из результата итератора\r\n        let nextValue = IteratorValue(nextResult);\r\n\r\n        // 9. Если mapping истинно, вызываем mapfn \r\n        // с thisArg и аргументами nextValue и k\r\n        let mappedValue = (mapping === true) ? Call(mapfn, thisArg, [nextValue, 𝔽(k)]) : nextValue;\r\n\r\n        let mappedValue;\r\n        // 9. Если mapping истинно,\r\n        if (mapping === true) {\r\n          // a. Вызываем mapfn с thisArg и аргументами nextValue и k\r\n          mappedValue = Call(mapfn, thisArg, [nextValue, 𝔽(k)]);\r\n          // b. Если вызов функции mapfn завершен с ошибкой, то закрываем итератор\r\n          ifAbruptCloseAsyncIterator(mappedValue, iteratorRecord);\r\n          // c. Если все хорошо, ожидаем результат,\r\n          // так как mapfn может возвращать Promise\r\n          mappedValue = Await(mappedValue);\r\n          // d. Если вызов функции mapfn завершен с ошибкой, то закрываем итератор\r\n          ifAbruptCloseAsyncIterator(mappedValue, iteratorRecord);\r\n        } else {\r\n          // 10. Если mapping ложно, устанавливаем mappedValue в nextValue\r\n          mappedValue = nextValue;\r\n        }\r\n\r\n        // 11. Создаем свойство в массиве A \r\n        // с ключом Pk и значением mappedValue\r\n        let defineStatus = CreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\r\n        // Если выполнение функции выше завершается с ошибкой, то закрываем итератор\r\n        if (defineStatus instanceof Completion) {\r\n          return AsyncIteratorClose(iteratorRecord, defineStatus);\r\n        }\r\n\r\n        // 13. Увеличиваем k на 1 и повторяем шаги\r\n        k = k + 1;\r\n      }\r\n    } else {\r\n      // 3i. NOTE: asyncItems не является AsyncIterable \r\n      // или Iterable, поэтому предполагаем, что это массивоподобный объект.\r\n      // 3ii. Получаем массивоподобный объект arrayLike\r\n      let arrayLike = ToObject(asyncItems);\r\n\r\n      // 3iii. Получаем длину arrayLike\r\n      let len = LengthOfArrayLike(arrayLike);\r\n\r\n      // 3iv. Если C является конструктором,\r\n      // создаем новый массив A с длиной len\r\n      // 3v. Иначе, создаем новый массив A\r\n      let A = (IsConstructor(C) === true) ? Construct(C, [𝔽(len)]) : ArrayCreate(len);\r\n\r\n      // 3vi. Устанавливаем k в 0\r\n      let k = 0;\r\n\r\n      // 3vii. Повторяем следующее, пока k < len\r\n      while (k < len) {\r\n        // 1. Получаем строковое представление числа k\r\n        let Pk = ToString(𝔽(k));\r\n        // 2. Получаем значение k-го элемента arrayLike\r\n        let kValue = Get(arrayLike, Pk);\r\n        // 3. Ожидаем значение, так как\r\n        // элемент массива может быть Promise\r\n        kValue = Await(kValue);\r\n\r\n        let mappedValue;\r\n        // 4. Если mapping истинно\r\n        if (mapping === true) {\r\n          // a. Вызываем mapfn с thisArg и аргументами kValue и k\r\n          mappedValue = Call(mapfn, thisArg, [kValue, 𝔽(k)]);\r\n          // b. Ожидаем результат, так как mapfn может возвращать Promise\r\n          mappedValue = Await(mappedValue);\r\n        } else {\r\n          // 5. Если mapping ложно, устанавливаем mappedValue в kValue\r\n          mappedValue = kValue;\r\n        }\r\n\r\n        // 6. Создаем свойство в массиве A\r\n        // с ключом Pk и значением mappedValue\r\n        CreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n\r\n        // 7. Увеличиваем k на 1 и повторяем шаги\r\n        k = k + 1;\r\n      }\r\n\r\n      // 3viii. Устанавливаем длину массива A в len\r\n      Set(A, \"length\", 𝔽(len), true);\r\n\r\n      // 3ix. Возвращаем массив A\r\n      return { [[Type]]: RETURN, [[Value]]: A, [[Target]]: EMPTY };\r\n    }\r\n  };\r\n\r\n  // 4. Запускаем выполнение асинхронной функции \r\n  // AsyncFunctionStart с promiseCapability \r\n  // и fromAsyncClosure в качестве аргументов\r\n  AsyncFunctionStart(promiseCapability, fromAsyncClosure);\r\n\r\n  // 5. Возвращаем promiseCapability.[[Promise]]\r\n  return promiseCapability.[[Promise]];\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let C be the this value.\r\n2. If mapfn is undefined, then\r\n   a. Let mapping be false.\r\n3. Else,\r\n   a. If IsCallable(mapfn) is false, throw a TypeError exception.\r\n   b. Let mapping be true.\r\n4. Let usingIterator be ? GetMethod(items, @@iterator).\r\n5. If usingIterator is not undefined, then\r\n   a. If IsConstructor(C) is true, then\r\n      i. Let A be ? Construct(C).\r\n   b. Else,\r\n      i. Let A be ! ArrayCreate(0).\r\n   c. Let iteratorRecord be ? GetIteratorFromMethod(items, usingIterator).\r\n   d. Let k be 0.\r\n   e. Repeat,\r\n      i. If k ≥ 2**53 - 1, then\r\n         1. Let error be ThrowCompletion(a newly created TypeError object).\r\n         2. Return ? IteratorClose(iteratorRecord, error).\r\n      ii. Let Pk be ! ToString(𝔽(k)).\r\n      iii. Let next be ? IteratorStepValue(iteratorRecord).\r\n      iv. If next is DONE, then\r\n         1. Perform ? Set(A, \"length\", 𝔽(k), true).\r\n         2. Return A.\r\n      v. If mapping is true, then\r\n         1. Let mappedValue be Completion(Call(mapfn, thisArg, « next, 𝔽(k) »)).\r\n         2. IfAbruptCloseIterator(mappedValue, iteratorRecord).\r\n      vi. Else,\r\n         1. Let mappedValue be next.\r\n      vii. Let defineStatus be Completion(CreateDataPropertyOrThrow(A, Pk, mappedValue)).\r\n      viii. IfAbruptCloseIterator(defineStatus, iteratorRecord).\r\n      ix. Set k to k + 1.\r\n6. NOTE: items is not an Iterable so assume it is an array-like object.\r\n7. Let arrayLike be ! ToObject(items).\r\n8. Let len be ? LengthOfArrayLike(arrayLike).\r\n9. If IsConstructor(C) is true, then\r\n   a. Let A be ? Construct(C, « 𝔽(len) »).\r\n10. Else,\r\n   a. Let A be ? ArrayCreate(len).\r\n11. Let k be 0.\r\n12. Repeat, while k < len,\r\n   a. Let Pk be ! ToString(𝔽(k)).\r\n   b. Let kValue be ? Get(arrayLike, Pk).\r\n   c. If mapping is true, then\r\n      i. Let mappedValue be ? Call(mapfn, thisArg, « kValue, 𝔽(k) »).\r\n   d. Else,\r\n      i. Let mappedValue be kValue.\r\n   e. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n   f. Set k to k + 1.\r\n13. Perform ? Set(A, \"length\", 𝔽(len), true).\r\n14. Return A.\r\n```",
        "parsedMethods": [
          "NewPromiseCapability()",
          "GetMethod()",
          "GetIterator()",
          "CreateAsyncFromSyncIterator()",
          "IsConstructor()",
          "Construct()",
          "ArrayCreate()",
          "ThrowCompletion()",
          "TypeError()",
          "AsyncIteratorClose()",
          "ToString()",
          "Call()",
          "Await()",
          "IsObject()",
          "IteratorComplete()",
          "Set()",
          "IteratorValue()",
          "CreateDataPropertyOrThrow()",
          "ToObject()",
          "LengthOfArrayLike()",
          "Get()",
          "AsyncFunctionStart()",
          "IsCallable()",
          "GetIteratorFromMethod()",
          "IteratorClose()",
          "IteratorStepValue()",
          "Completion()",
          "IfAbruptCloseIterator()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/proposal-array-from-async/#sec-array.fromAsync",
        "title": "Array.fromAsync()",
        "slug": "Array/Array.fromAsync()"
      },
      "Array/Array.isArray()": {
        "content": "Метод `Array.isArray()` возвращает `true`, если объект является массивом и `false`, если он массивом не является.\r\n\r\n##### Использование\r\n\r\n```js\r\n// true:\r\nArray.isArray([]);\r\nArray.isArray([1]);\r\nArray.isArray(new Array());\r\nArray.isArray(Array.prototype);\r\n\r\n// false:\r\nArray.isArray();\r\nArray.isArray({});\r\nArray.isArray(null);\r\nArray.isArray(undefined);\r\nArray.isArray(17);\r\nArray.isArray(\"Array\");\r\nArray.isArray(true);\r\nArray.isArray(false);\r\nArray.isArray({ __proto__: Array.prototype });\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\nArray.isArray = function(arg) {\r\n  return IsArray(arg);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Return ? IsArray(arg).\r\n```",
        "parsedMethods": [
          "Array()",
          "IsArray()"
        ],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.isarray",
        "title": "Array.isArray()",
        "slug": "Array/Array.isArray()"
      },
      "Array/Array.of()": {
        "content": "Метод `Array.of()` создаёт новый экземпляр массива `Array` из произвольного числа аргументов, вне зависимости от числа или типа аргумента.\r\n\r\nРазница между `Array.of()` и конструктором `Array` заключается в обработке целочисленных аргументов: `Array.of(7)` создаёт массив с одним элементом 7, а `Array(7)` создаёт пустой массив со значением свойства `length` равным 7 (Замечание: подразумевается 7 пустых слотов, а не слоты со значением `undefined`).\r\n\r\n##### Использование\r\n\r\n```js\r\n// true:\r\nArray.of(7); // [7]\r\nArray.of(1, 2, 3); // [1, 2, 3]\r\n\r\nArray(7); // массив с 7 пустыми слотами\r\nArray(1, 2, 3); // [1, 2, 3]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = items.length\r\n\r\n// this = C\r\nArray.of = function(...items) {\r\n  // 1. Получаем количество элементов в items\r\n  let len = items.length;\r\n\r\n  // 2. Получаем целое число lenNumber\r\n  let lenNumber = 𝔽(len);\r\n\r\n  // 3. Получаем this value\r\n  let C = this;\r\n\r\n  // 4. Если IsConstructor(C) равно true\r\n  if (IsConstructor(C)) {\r\n    // a. Создаем массив A с использованием C в качестве конструктора и lenNumber в качестве аргумента\r\n    let A = Construct(C, [lenNumber]);\r\n  } else {\r\n    // b. Иначе создаем массив A с использованием ArrayCreate и len в качестве аргумента\r\n    let A = ArrayCreate(len);\r\n  }\r\n\r\n  // 6. Инициализируем счетчик k\r\n  let k = 0;\r\n\r\n  // 7. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем значение k-го элемента\r\n    let kValue = items[k];\r\n\r\n    // b. Преобразуем k в строку и получаем Pk\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // c. Создаем свойство с ключом Pk и значением kValue в массиве A\r\n    CreateDataPropertyOrThrow(A, Pk, kValue);\r\n\r\n    // d. Увеличиваем счетчик k\r\n    k = k + 1;\r\n  }\r\n\r\n  // 8. Устанавливаем длину массива A в значение lenNumber\r\n  Set(A, \"length\", lenNumber, true);\r\n\r\n  // 9. Возвращаем созданный массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let len be the number of elements in items.\r\n2. Let lenNumber be 𝔽(len).\r\n3. Let C be the this value.\r\n4. If IsConstructor(C) is true, then\r\n   a. Let A be ? Construct(C, « lenNumber »).\r\n5. Else,\r\n   a. Let A be ? ArrayCreate(len).\r\n6. Let k be 0.\r\n7. Repeat, while k < len,\r\n   a. Let kValue be items[k].\r\n   b. Let Pk be ! ToString(𝔽(k)).\r\n   c. Perform ? CreateDataPropertyOrThrow(A, Pk, kValue).\r\n   d. Set k to k + 1.\r\n8. Perform ? Set(A, \"length\", lenNumber, true).\r\n9. Return A.\r\n```",
        "parsedMethods": [
          "Array()",
          "IsConstructor()",
          "Construct()",
          "ArrayCreate()",
          "ToString()",
          "CreateDataPropertyOrThrow()",
          "Set()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.of",
        "title": "Array.of()",
        "slug": "Array/Array.of()"
      },
      "Array/at()": {
        "content": "Метод `at()` принимает значение в виде целого числа и возвращает элемент массива с данным индексом. В качестве аргумента метод принимает положительные и отрицательные числа. При отрицательном значении отсчёт происходит с конца массива.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 3, 2];\r\n\r\nconsole.log(arr.at(1)); // 3\r\nconsole.log(arr.at(-1)); // 2\r\nconsole.log(arr.at(3)); // undefined\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// this = arr\r\nArray.prototype.at = function(index) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  // Здесь это не нужно, так как arr уже является объектом\r\n  // (массив - это объект)\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем полученный индекс в целое число (или бесконечность)\r\n  let relativeIndex = ToIntegerOrInfinity(index);\r\n\r\n  // 4. Если relativeIndex >= 0, устанавливаем k = relativeIndex\r\n  // 5. Иначе устанавливаем k = len + relativeIndex\r\n  let k = (relativeIndex >= 0) ? relativeIndex : (len + relativeIndex);\r\n\r\n  // 6. Если k выходит за пределы arr, возвращаем undefined\r\n  if (k < 0 || k >= len) {\r\n    return undefined;\r\n  }\r\n\r\n  // 7. Возвращаем значение, полученное из объекта obj по ключу k\r\n  return Get(obj, ToString(𝔽(k)));\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeIndex be ? ToIntegerOrInfinity(index).\r\n4. If relativeIndex ≥ 0, then\r\n  a. Let k be relativeIndex.\r\n5. Else,\r\n  a. Let k be len + relativeIndex.\r\n6. If k < 0 or k ≥ len, return undefined.\r\n7. Return ? Get(O, ! ToString(𝔽(k))).\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "Get()",
          "ToString()"
        ],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.at",
        "title": "at()",
        "slug": "Array/at()"
      },
      "Array/concat()": {
        "content": "Метод `concat()` возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr1 = ['a', 'b', 'c'];\r\nconst arr2 = ['d', 'e', 'f'];\r\nconst g = 'g';\r\nconst arr3 = arr1.concat(arr2, g);\r\n\r\nconsole.log(arr3); // ['a', 'b', 'c', 'd', 'e', 'f', 'g']\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr1.length\r\n// m = items.length\r\n// k = items[i].length (max)\r\n\r\n// this = arr1\r\nArray.prototype.concat = function(...items) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  // Здесь это не нужно, так как arr1 уже является объектом\r\n  // (массив - это объект)\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Создаем новый массив A длины 0\r\n  let A = ArraySpeciesCreate(obj, 0);\r\n\r\n  // 3. Инициализируем счетчик n\r\n  let n = 0;\r\n\r\n  // 4. Добавляем obj в начало items\r\n  items.unshift(obj);\r\n\r\n  // 5. Для каждого элемента E в items\r\n  for (const E of items) {\r\n    // a. Проверяем, расширяем ли элемент\r\n    let spreadable = IsConcatSpreadable(E);\r\n\r\n    // b. Если расширяем\r\n    if (spreadable === true) {\r\n      // i. Получаем длину массивоподобного объекта E\r\n      let len = LengthOfArrayLike(E);\r\n\r\n      // ii. Проверяем, не превысит ли длина нового массива максимальное значение\r\n      if (n + len > 2**53 - 1) {\r\n        throw new TypeError(\"Concatenation result exceeds the maximum array length\");\r\n      }\r\n\r\n      // iii. Инициализируем счетчик k\r\n      let k = 0;\r\n\r\n      // iv. Повторяем, пока k < len\r\n      while (k < len) {\r\n        // 1. Получаем строковое представление индекса k\r\n        let Pk = ToString(𝔽(k));\r\n\r\n        // 2. Проверяем, существует ли свойство с индексом k в E\r\n        let exists = HasProperty(E, Pk);\r\n\r\n        // 3. Если свойство существует\r\n        if (exists === true) {\r\n          // a. Получаем подэлемент под индексом k\r\n          let subElement = Get(E, Pk);\r\n\r\n          // b. Добавляем подэлемент в новый массив\r\n          CreateDataPropertyOrThrow(A, ToString(𝔽(n)), subElement);\r\n        }\r\n\r\n        // 4. Увеличиваем счетчик n и k\r\n        n = n + 1;\r\n        k = k + 1;\r\n      }\r\n    } else {\r\n      // c. Если нерасширяем\r\n      // i. Добавляем элемент E в новый массив\r\n      CreateDataPropertyOrThrow(A, ToString(𝔽(n)), E);\r\n\r\n      // ii. Увеличиваем счетчик n\r\n      n = n + 1;\r\n    }\r\n  }\r\n\r\n  // 6. Устанавливаем длину нового массива в значение n\r\n  Set(A, \"length\", 𝔽(n), true);\r\n\r\n  // 7. Возвращаем новый массив\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let A be ? ArraySpeciesCreate(O, 0).\r\n3. Let n be 0.\r\n4. Prepend O to items.\r\n5. For each element E of items, do\r\n  a. Let spreadable be ? IsConcatSpreadable(E).\r\n  b. If spreadable is true, then\r\n    i. Let len be ? LengthOfArrayLike(E).\r\n    ii. If n + len > 253 - 1, throw a TypeError exception.\r\n    iii. Let k be 0.\r\n    iv. Repeat, while k < len,\r\n      1. Let P be ! ToString(𝔽(k)).\r\n      2. Let exists be ? HasProperty(E, P).\r\n      3. If exists is true, then\r\n        a. Let subElement be ? Get(E, P).\r\n        b. Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), subElement).\r\n      4. Set n to n + 1.\r\n      5. Set k to k + 1.\r\n  c. Else,\r\n    i. NOTE: E is added as a single item rather than spread.\r\n    ii. If n ≥ 253 - 1, throw a TypeError exception.\r\n    iii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), E).\r\n    iv. Set n to n + 1.\r\n6. Perform ? Set(A, \"length\", 𝔽(n), true).\r\n7. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "ArraySpeciesCreate()",
          "IsConcatSpreadable()",
          "LengthOfArrayLike()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "CreateDataPropertyOrThrow()",
          "Set()"
        ],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n + m * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n + m * k)",
          "color": "orange"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.concat",
        "title": "concat()",
        "slug": "Array/concat()"
      },
      "Array/copyWithin()": {
        "content": "Метод `copyWithin()` копирует последовательность элементов массива внутри него в позицию, начинающуюся по индексу `target`. Копия берётся по индексам, задаваемым вторым и третьим аргументами `start` и `end` (могут быть отрицательными, тогда отсчет происходит с конца массива). Аргумент `end` является необязательным и по умолчанию равен длине массива.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr1 = [1, 2, 3, 4, 5];\r\narr1.copyWithin(0, 3);\r\n// [4, 5, 3, 4, 5]\r\n\r\nconst arr2 = [1, 2, 3, 4, 5];\r\narr2.copyWithin(0, 3, 4);\r\n// [4, 2, 3, 4, 5]\r\n\r\nconst arr3 = [1, 2, 3, 4, 5];\r\narr3.copyWithin(0, -2, -1);\r\n// [4, 2, 3, 4, 5]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = count\r\n\r\n// this = arr\r\nArray.prototype.copyWithin = function(target, start, end = this.length) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  // Здесь это не нужно, так как arr уже является объектом\r\n  // (массив - это объект)\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Создаем relativeTarget = target, преобразованный в целое число или бесконечность\r\n  let relativeTarget = ToIntegerOrInfinity(target);\r\n\r\n  // 4-6. Вычисляем индекс to (куда будем копировать)\r\n  let to;\r\n\r\n  if (relativeTarget === -Infinity) {\r\n    to = 0;\r\n  } else if (relativeTarget < 0) { // если target отрицательный\r\n    to = max(len + relativeTarget, 0);\r\n  } else {\r\n    to = min(relativeTarget, len);\r\n  }\r\n\r\n  // 7. Создаем relativeStart = start, преобразованный в целое число или бесконечность\r\n  let relativeStart = ToIntegerOrInfinity(start);\r\n\r\n  // 8-10. Вычисляем начальный индекс для копирования\r\n  let from;\r\n\r\n  if (relativeStart === -Infinity) {\r\n    from = 0;\r\n  } else if (relativeStart < 0) {\r\n    from = max(len + relativeStart, 0);\r\n  } else {\r\n    from = min(relativeStart, len);\r\n  }\r\n\r\n  // 11. Если end равен undefined, то relativeEnd = len,\r\n  // иначе преобразуем end в целое число или бексконечность\r\n  let relativeEnd;\r\n  if (end === undefined) {\r\n    relativeEnd = len;\r\n  } else {\r\n    relativeEnd = ToIntegerOrInfinity(end);\r\n  }\r\n\r\n  // 12-14. Вычисляем конечный индекс для копирования\r\n  let final;\r\n  if (relativeEnd === -Infinity) {\r\n    final = 0;\r\n  } else if (relativeEnd < 0) {\r\n    final = max(len + relativeEnd, 0);\r\n  } else {\r\n    final = min(relativeEnd, len);\r\n  }\r\n\r\n  // 15. Вычисляем количество элементов для копирования\r\n  let count = min(final - from, len - to);\r\n\r\n  // 16-17. Определяем направление копирования\r\n  let direction;\r\n  if (from < to && to < from + count) {\r\n    direction = -1;\r\n    from = from + count - 1;\r\n    to = to + count - 1;\r\n  } else {\r\n    direction = 1;\r\n  }\r\n\r\n  // 18. Копируем элементы в новый диапазон\r\n  while (count > 0) {\r\n    let fromkey = ToString(𝔽(from));\r\n    let toKey = ToString(𝔽(to));\r\n    let fromPresent = HasProperty(obj, fromKey);\r\n\r\n    if (fromPresent === true) {\r\n      // если элемент есть в obj, копируем его\r\n      let fromVal = Get(obj, fromKey);\r\n      Set(obj, toKey, fromVal, true);\r\n    } else {\r\n      // если элемент отсутствует, удаляем соответствующий\r\n      // элемент в новом диапазоне\r\n      DeletePropertyOrThrow(obj, toKey);\r\n    }\r\n\r\n    from += direction;\r\n    to += direction;\r\n    count--;\r\n  }\r\n\r\n  // 19. Возвращаем измененный массив\r\n  return obj;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeTarget be ? ToIntegerOrInfinity(target).\r\n4. If relativeTarget = -∞, let to be 0.\r\n5. Else if relativeTarget < 0, let to be max(len + relativeTarget, 0).\r\n6. Else, let to be min(relativeTarget, len).\r\n7. Let relativeStart be ? ToIntegerOrInfinity(start).\r\n8. If relativeStart = -∞, let from be 0.\r\n9. Else if relativeStart < 0, let from be max(len + relativeStart, 0).\r\n10. Else, let from be min(relativeStart, len).\r\n11. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToIntegerOrInfinity(end).\r\n12. If relativeEnd = -∞, let final be 0.\r\n13. Else if relativeEnd < 0, let final be max(len + relativeEnd, 0).\r\n14. Else, let final be min(relativeEnd, len).\r\n15. Let count be min(final - from, len - to).\r\n16. If from < to and to < from + count, then\r\n  a. Let direction be -1.\r\n  b. Set from to from + count - 1.\r\n  c. Set to to to + count - 1.\r\n17. Else,\r\n  a. Let direction be 1.\r\n18. Repeat, while count > 0,\r\n  a. Let fromKey be ! ToString(𝔽(from)).\r\n  b. Let toKey be ! ToString(𝔽(to)).\r\n  c. Let fromPresent be ? HasProperty(O, fromKey).\r\n  d. If fromPresent is true, then\r\n    i. Let fromVal be ? Get(O, fromKey).\r\n    ii. Perform ? Set(O, toKey, fromVal, true).\r\n  e. Else,\r\n    i. Assert: fromPresent is false.\r\n    ii. Perform ? DeletePropertyOrThrow(O, toKey).\r\n  f. Set from to from + direction.\r\n  g. Set to to to + direction.\r\n  h. Set count to count - 1.\r\n19. Return O.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Set()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.copywithin",
        "title": "copyWithin()",
        "slug": "Array/copyWithin()"
      },
      "Array/entries()": {
        "content": "Метод `entries()` возвращает новый объект итератора массива `Array Iterator`, содержащий пары ключ-значение для каждого индекса в массиве.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = ['a', 'b', 'c'];\r\nconst arrEntries = arr.entries();\r\n\r\nconsole.log(arrEntries.next().value); // [0, 'a']\r\nconsole.log(arrEntries.next().value); // [1, 'b']\r\nconsole.log(arrEntries.next().value); // [2, 'c']\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.entries = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Создаем и возвращаем новый объект итератора для массива obj. \r\n  // Итератор будет возвращать пары ключ-значение для каждого \r\n  // элемента в массиве. Параметр key+value указывает, что итератор \r\n  // должен возвращать как ключ, так и значение для каждого элемента.\r\n  return CreateArrayIterator(obj, key+value);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Return CreateArrayIterator(O, KEY+VALUE).\r\n```",
        "parsedMethods": [
          "ToObject()",
          "CreateArrayIterator()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.entries",
        "title": "entries()",
        "slug": "Array/entries()"
      },
      "Array/every()": {
        "content": "Метод `every()` проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.\r\n\r\n##### Использование\r\n\r\n```js\r\nfunction isBigEnough(element, index, array) {\r\n  return element >= 10;\r\n}\r\n\r\n[12, 5, 8, 130, 44].every(isBigEnough); // false\r\n[12, 54, 18, 130, 44].every(isBigEnough); // true\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n\r\n// this = arr\r\nArray.prototype.every = function(callbackfn, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError('callbackfn is not a function');\r\n  }\r\n\r\n  // 4. Инициализируем счетчик k значением 0\r\n  let k = 0;\r\n\r\n  // 5. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковый индекс Pk для текущего значения k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, существует ли свойство с индексом Pk в объекте obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство существует\r\n    if (kPresent === true) {\r\n      // i. Получаем значение элемента по индексу Pk\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Вызываем callbackfn с аргументами kValue, 𝔽(k), obj\r\n      let testResult = ToBoolean(Call(callbackfn, thisArg, [kValue, 𝔽(k), obj]));\r\n\r\n      // iii. Если результат вызова callbackfn равен false, возвращаем false\r\n      if (testResult === false) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // d. Увеличиваем счетчик k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 6. Если цикл завершился без возвращения false, возвращаем true\r\n  return true;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. Let k be 0.\r\n5. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Let testResult be ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)).\r\n    iii. If testResult is false, return false.\r\n  d. Set k to k + 1.\r\n6. Return true.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "ToBoolean()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.every",
        "title": "every()",
        "slug": "Array/every()"
      },
      "Array/fill()": {
        "content": "Метод `fill()` заполняет все элементы массива от начального до конечного индексов одним значением.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst array1 = [1, 2, 3, 4];\r\n\r\nconsole.log(array1.fill(0, 2, 4));\r\n// [1, 2, 0, 0]\r\n\r\nconsole.log(array1.fill(5, 1));\r\n// [1, 5, 5, 5]\r\n\r\nconsole.log(array1.fill(6));\r\n// [6, 6, 6, 6]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.fill = function(value, start, end) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем полученный индекс начала заполнения в целое число (или бесконечность)\r\n  let relativeStart = ToIntegerOrInfinity(start);\r\n\r\n  // 4. Если relativeStart = -∞, устанавливаем k = 0\r\n  // 5. Иначе, если relativeStart < 0, устанавливаем k = max(len + relativeStart, 0)\r\n  // 6. Иначе, устанавливаем k = min(relativeStart, len)\r\n  let k = (relativeStart === -Infinity) ? 0 : ((relativeStart < 0) ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len));\r\n\r\n  // 7. Если конечный индекс не определен, устанавливаем relativeEnd = len\r\n  // Иначе, устанавливаем relativeEnd = ToIntegerOrInfinity(end)\r\n  let relativeEnd = (end === undefined) ? len : ToIntegerOrInfinity(end);\r\n\r\n  // 8. Если relativeEnd = -∞, устанавливаем final = 0\r\n  // 9. Иначе, если relativeEnd < 0, устанавливаем final = max(len + relativeEnd, 0)\r\n  // 10. Иначе, устанавливаем final = min(relativeEnd, len)\r\n  let final = (relativeEnd === -Infinity) ? 0 : ((relativeEnd < 0) ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len));\r\n\r\n  // 11. Пока k < final,\r\n  //   a. Получаем строковое представление текущего индекса Pk\r\n  //   b. Устанавливаем значение value по ключу Pk в объекте obj\r\n  //   c. Увеличиваем k на 1\r\n  while (k < final) {\r\n    let Pk = ToString(𝔽(k));\r\n    Set(obj, Pk, value, true);\r\n    k++;\r\n  }\r\n\r\n  // 12. Возвращаем объект obj\r\n  return obj;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeStart be ? ToIntegerOrInfinity(start).\r\n4. If relativeStart = -∞, let k be 0.\r\n5. Else if relativeStart < 0, let k be max(len + relativeStart, 0).\r\n6. Else, let k be min(relativeStart, len).\r\n7. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToIntegerOrInfinity(end).\r\n8. If relativeEnd = -∞, let final be 0.\r\n9. Else if relativeEnd < 0, let final be max(len + relativeEnd, 0).\r\n10. Else, let final be min(relativeEnd, len).\r\n11. Repeat, while k < final,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Perform ? Set(O, Pk, value, true).\r\n  c. Set k to k + 1.\r\n12. Return O.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "ToString()",
          "Set()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.fill",
        "title": "fill()",
        "slug": "Array/fill()"
      },
      "Array/filter()": {
        "content": "Метод `filter()` создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = ['spray', 'elite', 'exuberant', 'destruction', 'present'];\r\n\r\nconst result = arr.filter((word) => word.length > 6);\r\n\r\nconsole.log(result);\r\n// [\"exuberant\", \"destruction\", \"present\"]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n\r\n// this = arr\r\nArray.prototype.filter = function(callbackfn, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError('Callback is not a function');\r\n  }\r\n\r\n  // 4. Создаем новый массив A с использованием ArraySpeciesCreate\r\n  let A = ArraySpeciesCreate(obj, 0);\r\n\r\n  // 5-6. Устанавливаем начальные значения k и to\r\n  let k = 0;\r\n  let to = 0;\r\n\r\n  // 7. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем ключ Pk\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, присутствует ли свойство с ключом Pk в объекте obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство присутствует, выполняем следующие шаги\r\n    if (kPresent) {\r\n      // i. Получаем значение свойства kValue\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Вызываем callbackfn с аргументами kValue, 𝔽(k), и obj\r\n      let selected = ToBoolean(Call(callbackfn, thisArg, [kValue, 𝔽(k), obj]));\r\n\r\n      // iii. Если результат вызова callbackfn равен true, выполняем следующие шаги\r\n      if (selected) {\r\n        // 1. Добавляем свойство в массив A с ключом to и значением kValue\r\n        CreateDataPropertyOrThrow(A, ToString(𝔽(to)), kValue);\r\n\r\n        // 2. Увеличиваем to на 1\r\n        to = to + 1;\r\n      }\r\n    }\r\n\r\n    // d. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 8. Возвращаем массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. Let A be ? ArraySpeciesCreate(O, 0).\r\n5. Let k be 0.\r\n6. Let to be 0.\r\n7. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Let selected be ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)).\r\n    iii. If selected is true, then\r\n      1. Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(to)), kValue).\r\n      2. Set to to to + 1.\r\n  d. Set k to k + 1.\r\n8. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ArraySpeciesCreate()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "ToBoolean()",
          "Call()",
          "CreateDataPropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.filter",
        "title": "filter()",
        "slug": "Array/filter()"
      },
      "Array/find()": {
        "content": "Метод `find()` возвращает **значение** первого найденного в массиве элемента, которое удовлетворяет условию, переданному в callback функции. В противном случае возвращается `undefined`.\r\n\r\n##### Использование\r\n\r\n```js\r\nfunction isPrime(element, index, array) {\r\n  var start = 2;\r\n  while (start <= Math.sqrt(element)) {\r\n    if (element % start++ < 1) {\r\n      return false;\r\n    }\r\n  }\r\n  return element > 1;\r\n}\r\n\r\nconsole.log([4, 6, 8, 12].find(isPrime)); // undefined\r\nconsole.log([4, 5, 8, 12].find(isPrime)); // 5\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = predicate\r\n\r\n// this = arr\r\nArray.prototype.find = function(predicate, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Выполняем поиск с использованием предиката и заданного thisArg\r\n  let findRec = FindViaPredicate(obj, len, ASCENDING, predicate, thisArg);\r\n\r\n  // 4. Возвращаем значение найденного элемента\r\n  return findRec.[[Value]];\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let findRec be ? FindViaPredicate(O, len, ASCENDING, predicate, thisArg).\r\n4. Return findRec.[[Value]].\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "FindViaPredicate()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find",
        "title": "find()",
        "slug": "Array/find()"
      },
      "Array/findIndex()": {
        "content": "Метод `findIndex()` возвращает **индекс** в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.\r\n\r\n##### Использование\r\n\r\n```js\r\nfunction isPrime(element, index, array) {\r\n  var start = 2;\r\n  while (start <= Math.sqrt(element)) {\r\n    if (element % start++ < 1) {\r\n      return false;\r\n    }\r\n  }\r\n  return element > 1;\r\n}\r\n\r\nconsole.log([4, 6, 8, 12].findIndex(isPrime)); // -1\r\nconsole.log([4, 6, 7, 12].findIndex(isPrime)); // 2\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = predicate\r\n\r\n// this = arr\r\nArray.prototype.findIndex = function(predicate, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Выполняем поиск с использованием предиката и заданного thisArg\r\n  let findRec = FindViaPredicate(obj, len, ASCENDING, predicate, thisArg);\r\n\r\n  // 4. Возвращаем индекс найденного элемента или -1, если элемент не найден\r\n  return findRec.[[Index]];\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let findRec be ? FindViaPredicate(O, len, ASCENDING, predicate, thisArg).\r\n4. Return findRec.[[Index]].\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "FindViaPredicate()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findindex",
        "title": "findIndex()",
        "slug": "Array/findIndex()"
      },
      "Array/findLast()": {
        "content": "Метод `findLast()` итерируется по массиву в обратном порядке и возвращает **значение** первого найденного в массиве элемента, которое удовлетворяет условию, переданному в callback функции. В противном случае возвращается `undefined`.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst array1 = [5, 12, 50, 130, 44];\r\n\r\nconst found = array1.findLast((element) => element > 45);\r\n\r\nconsole.log(found);\r\n// Expected output: 130\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = predicate\r\n\r\n// this = arr\r\nArray.prototype.findLast = function(predicate, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Выполняем поиск с использованием предиката \r\n  // и заданного thisArg в порядке убывания индексов\r\n  let findRec = FindViaPredicate(obj, len, DESCENDING, predicate, thisArg);\r\n\r\n  // 4. Возвращаем значение, найденное в результате поиска\r\n  return findRec.[[Value]];\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let findRec be ? FindViaPredicate(O, len, DESCENDING, predicate, thisArg).\r\n4. Return findRec.[[Value]].\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "FindViaPredicate()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findlast",
        "title": "findLast()",
        "slug": "Array/findLast()"
      },
      "Array/findLastIndex()": {
        "content": "Метод `findLastIndex()` итерируется по массиву в обратном порядке и возвращает **индекс** в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае возвращается -1.\r\n\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [5, 12, 50, 130, 44];\r\n\r\nconst isLargeNumber = (element) => element > 45;\r\n\r\nconsole.log(arr.findLastIndex(isLargeNumber));\r\n// 3\r\n// arr[3] -> 130\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = predicate\r\n\r\n// this = arr\r\nArray.prototype.findLastIndex = function(predicate, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Выполняем поиск с использованием предиката\r\n  // и заданного thisArg в порядке убывания индексов\r\n  let findRec = FindViaPredicate(obj, len, DESCENDING, predicate, thisArg);\r\n\r\n  // 4. Возвращаем индекс найденного элемента или -1, если элемент не найден\r\n  return findRec.[[Index]];\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let findRec be ? FindViaPredicate(O, len, DESCENDING, predicate, thisArg).\r\n4. Return findRec.[[Index]].\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "FindViaPredicate()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.findlastindex",
        "title": "findLastIndex()",
        "slug": "Array/findLastIndex()"
      },
      "Array/flat()": {
        "content": "Метод `flat()` возвращает новый массив, в котором все элементы вложенных подмассивов были рекурсивно \"подняты\" на указанный уровень depth.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr1 = [1, 2, [3, 4]];\r\narr1.flat();\r\n// [1, 2, 3, 4]\r\n\r\nconst arr2 = [1, 2, [3, 4, [5, 6]]];\r\narr2.flat();\r\n// [1, 2, 3, 4, [5, 6]]\r\n\r\nconst arr3 = [1, 2, [3, 4, [5, 6]]];\r\narr3.flat(2);\r\n// [1, 2, 3, 4, 5, 6]\r\n\r\nconst arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];\r\narr4.flat(Infinity);\r\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = A.length (результирующий массив)\r\n\r\n// this = arr\r\nArray.prototype.flat = function(depth) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let sourceLen = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если depth не определено, устанавливаем depthNum в 1\r\n  let depthNum = 1;\r\n\r\n  // 4. Если depth определено, преобразуем его в целое число\r\n  if (depth !== undefined) {\r\n    depthNum = ToIntegerOrInfinity(depth);\r\n\r\n    // 4a. Если depthNum < 0, устанавливаем depthNum в 0\r\n    if (depthNum < 0) {\r\n      depthNum = 0;\r\n    }\r\n  }\r\n\r\n  // 5. Создаем новый массив A\r\n  let A = ArraySpeciesCreate(obj, 0);\r\n\r\n  // 6. Выполняем процедуру сглаживания массива FlattenIntoArray\r\n  FlattenIntoArray(A, obj, sourceLen, 0, depthNum);\r\n\r\n  // 7. Возвращаем полученный массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let sourceLen be ? LengthOfArrayLike(O).\r\n3. Let depthNum be 1.\r\n4. If depth is not undefined, then\r\n  a. Set depthNum to ? ToIntegerOrInfinity(depth).\r\n  b. If depthNum < 0, set depthNum to 0.\r\n5. Let A be ? ArraySpeciesCreate(O, 0).\r\n6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, depthNum).\r\n7. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "ArraySpeciesCreate()",
          "FlattenIntoArray()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.flat",
        "title": "flat()",
        "slug": "Array/flat()"
      },
      "Array/flatMap()": {
        "content": "Метод `flatMap()` сначала применяет функцию к каждому элементу, а затем преобразует полученный результат в плоскую структуру и помещает в новый массив. Это идентично `map` функции, с последующим применением функции `flat` с параметром `depth` (глубина) равным 1, но `flatMap` часто бывает полезным, так как работает немного более эффективно.\r\n\r\n##### Использование\r\n\r\n```js\r\nlet arr1 = [1, 2, 3, 4];\r\n\r\narr1.map((x) => [x * 2]);\r\n// [[2], [4], [6], [8]]\r\n\r\narr1.flatMap((x) => [x * 2]);\r\n// [2, 4, 6, 8]\r\n\r\n// выравнивается только один уровень\r\narr1.flatMap((x) => [[x * 2]]);\r\n// [[2], [4], [6], [8]]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = A.length (результирующий массив)\r\n// k = mapperFunction\r\n\r\n// this = arr\r\nArray.prototype.flatMap = function(mapperFunction, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let sourceLen = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если mapperFunction не является callable, выбрасываем исключение TypeError\r\n  if (!IsCallable(mapperFunction)) {\r\n    throw new TypeError(\"mapperFunction is not callable\");\r\n  }\r\n\r\n  // 4. Создаем новый массив A с использованием ArraySpeciesCreate\r\n  let A = ArraySpeciesCreate(obj, 0);\r\n\r\n  // 5. Выполняем FlattenIntoArray для слияния элементов массива\r\n  FlattenIntoArray(A, obj, sourceLen, 0, 1, mapperFunction, thisArg);\r\n\r\n  // 6. Возвращаем новый массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let sourceLen be ? LengthOfArrayLike(O).\r\n3. If IsCallable(mapperFunction) is false, throw a TypeError exception.\r\n4. Let A be ? ArraySpeciesCreate(O, 0).\r\n5. Perform ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, thisArg).\r\n6. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ArraySpeciesCreate()",
          "FlattenIntoArray()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.flatmap",
        "title": "flatMap()",
        "slug": "Array/flatMap()"
      },
      "Array/forEach()": {
        "content": "Метод `forEach()` выполняет указанную функцию один раз для каждого элемента в массиве.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = ['a', 'b', 'c'];\r\n\r\narr.forEach((element) => console.log(element));\r\n\r\n// \"a\"\r\n// \"b\"\r\n// \"c\"\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n\r\n// this = arr\r\nArray.prototype.forEach = function(callbackfn, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    // Если нет, выбрасываем исключение TypeError\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 4. Устанавливаем начальное значение счетчика k = 0\r\n  let k = 0;\r\n\r\n  // 5. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковое представление k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, есть ли свойство с ключом Pk в объекте obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство существует, выполняем следующие шаги\r\n    if (kPresent === true) {\r\n      // i. Получаем значение свойства по ключу Pk\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Вызываем функцию callbackfn с аргументами kValue, 𝔽(k), obj\r\n      Call(callbackfn, thisArg, [kValue, 𝔽(k), obj]);\r\n    }\r\n\r\n    // d. Увеличиваем счетчик k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 6. Возвращаем undefined\r\n  return undefined;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. Let k be 0.\r\n5. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Perform ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »).\r\n  d. Set k to k + 1.\r\n6. Return undefined.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.foreach",
        "title": "forEach()",
        "slug": "Array/forEach()"
      },
      "Array/includes()": {
        "content": "Метод `includes()` определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого `true` или `false`.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2, 3];\r\n\r\nconsole.log(arr.includes(2));\r\n// true\r\n\r\nconst pets = ['cat', 'dog', 'bat'];\r\n\r\nconsole.log(pets.includes('cat'));\r\n// true\r\n\r\nconsole.log(pets.includes('at'));\r\n// false\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.includes = function(searchElement, fromIndex) {\r\n// 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если длина массива равна 0, возвращаем false\r\n  if (len === 0) {\r\n    return false;\r\n  }\r\n\r\n  // 4. Преобразуем величину fromIndex в целое число (или бесконечность)\r\n  let n = ToIntegerOrInfinity(fromIndex);\r\n\r\n  // 5. Проверка: если fromIndex не определен, устанавливаем n в 0\r\n  if (fromIndex === undefined) {\r\n    n = 0;\r\n  }\r\n\r\n  // 6. Если n = +∞, возвращаем false\r\n  // 7. Иначе, если n = -∞, устанавливаем n в 0\r\n  if (n === +Infinity) {\r\n    return false;\r\n  } else if (n === -Infinity) {\r\n    n = 0;\r\n  }\r\n\r\n  let k;\r\n  // 8. Если n >= 0, устанавливаем k = n\r\n  // 9. Иначе, устанавливаем k = len + n и если k < 0, устанавливаем k в 0\r\n  if (n >= 0) {\r\n    k = n;\r\n  } else {\r\n    k = len + n;\r\n\r\n    if (k < 0) {\r\n      k = 0;\r\n    }\r\n  }\r\n\r\n  // 10. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем элемент массива с индексом k\r\n    let elementK = Get(obj, ToString(𝔽(k)));\r\n\r\n    // b. Если элементK равен searchElement, возвращаем true\r\n    if (SameValueZero(searchElement, elementK)) {\r\n      return true;\r\n    }\r\n\r\n    // c. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 11. Если не найдено совпадение, возвращаем false\r\n  return false;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If len = 0, return false.\r\n4. Let n be ? ToIntegerOrInfinity(fromIndex).\r\n5. Assert: If fromIndex is undefined, then n is 0.\r\n6. If n = +∞, return false.\r\n7. Else if n = -∞, set n to 0.\r\n8. If n ≥ 0, then\r\n  a. Let k be n.\r\n9. Else,\r\n  a. Let k be len + n.\r\n  b. If k < 0, set k to 0.\r\n10. Repeat, while k < len,\r\n  a. Let elementK be ? Get(O, ! ToString(𝔽(k))).\r\n  b. If SameValueZero(searchElement, elementK) is true, return true.\r\n  c. Set k to k + 1.\r\n11. Return false.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "Get()",
          "ToString()",
          "SameValueZero()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.includes",
        "title": "includes()",
        "slug": "Array/includes()"
      },
      "Array/indexOf()": {
        "content": "Метод `indexOf()` возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [2, 5, 9];\r\narr.indexOf(2); // 0\r\narr.indexOf(7); // -1\r\narr.indexOf(9, 2); // 2\r\narr.indexOf(2, -1); // -1\r\narr.indexOf(2, -3); // 0\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.indexOf = function(searchElement, fromIndex) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если длина массива равна 0, возвращаем -1\r\n  if (len === 0) {\r\n    return -1;\r\n  }\r\n\r\n  // 4. Преобразуем величину fromIndex в целое число (или бесконечность)\r\n  let n = ToIntegerOrInfinity(fromIndex);\r\n\r\n  // 5. Проверка: если fromIndex не определен, устанавливаем n в 0\r\n  if (fromIndex === undefined) {\r\n    n = 0;\r\n  }\r\n\r\n  // 6. Если n = +∞, возвращаем false\r\n  // 7. Иначе, если n = -∞, устанавливаем n в 0\r\n  if (n === +Infinity) {\r\n    return -1;\r\n  } else if (n === -Infinity) {\r\n    n = 0;\r\n  }\r\n\r\n  let k;\r\n  // 8. Если n ≥ 0, устанавливаем k = n\r\n  // 9. Иначе, устанавливаем k = len + n, если k < 0, устанавливаем k в 0\r\n  if (n >= 0) {\r\n    k = n;\r\n  } else {\r\n    k = len + n;\r\n\r\n    if (k < 0) {\r\n      k = 0;\r\n    }\r\n  }\r\n\r\n  // 10. Пока k < len\r\n  while (k < len) {\r\n    // a. Проверяем, есть ли свойство с ключом k\r\n    let kPresent = HasProperty(obj, ToString(𝔽(k)));\r\n\r\n    // b. Если свойство есть\r\n    if (kPresent) {\r\n      // i. Получаем значение элемента по ключу k\r\n      let elementK = Get(obj, ToString(𝔽(k)));\r\n\r\n      // ii. Если значения равны, возвращаем индекс k\r\n      if (IsStrictlyEqual(searchElement, elementK)) {\r\n        return 𝔽(k);\r\n      }\r\n    }\r\n\r\n    // c. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 11. Если ничего не найдено, возвращаем -1\r\n  return -1;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If len = 0, return -1𝔽.\r\n4. Let n be ? ToIntegerOrInfinity(fromIndex).\r\n5. Assert: If fromIndex is undefined, then n is 0.\r\n6. If n = +∞, return -1𝔽.\r\n7. Else if n = -∞, set n to 0.\r\n8. If n ≥ 0, then\r\n   a. Let k be n.\r\n9. Else,\r\n   a. Let k be len + n.\r\n   b. If k < 0, set k to 0.\r\n10. Repeat, while k < len,\r\n    a. Let kPresent be ? HasProperty(O, ! ToString(𝔽(k))).\r\n    b. If kPresent is true, then\r\n       i. Let elementK be ? Get(O, ! ToString(𝔽(k))).\r\n       ii. If IsStrictlyEqual(searchElement, elementK) is true, return 𝔽(k).\r\n    c. Set k to k + 1.\r\n11. Return -1𝔽.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "HasProperty()",
          "ToString()",
          "Get()",
          "IsStrictlyEqual()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.indexof",
        "title": "indexOf()",
        "slug": "Array/indexOf()"
      },
      "Array/join()": {
        "content": "Метод `join()` объединяет все элементы массива (или массивоподобного объекта) в строку.\r\n\r\nМожно заметить, что во внутренней реализации метода используется конкатенация строк (`+=`), но, если бы мы осуществляли конкатенацию строк вручную в цикле, мы бы заметили, что она работает медленнее, чем метод `join()`. Это обусловлено тем, что движки оптимизируют метод `join()`. Однако, оптимизации могут различаться в зависимости от движка и конкретных условий, поэтому в некоторых сценариях конкатенация строк (`+=`) может работать быстрее, либо нараване с методом `join()`.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst elements = ['Fire', 'Air', 'Water'];\r\n\r\nconsole.log(elements.join());\r\n// \"Fire,Air,Water\"\r\n\r\nconsole.log(elements.join(''));\r\n// \"FireAirWater\"\r\n\r\nconsole.log(elements.join('-'));\r\n// \"Fire-Air-Water\"\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = R.length (результирующая строка)\r\n\r\n// this = arr\r\nArray.prototype.join = function(separator) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если separator не определен, устанавливаем sep = \",\"\r\n  // 4. Иначе устанавливаем sep = separator\r\n  let sep = (separator === undefined) ? \",\" : ToString(separator);\r\n\r\n  // 5. Устанавливаем R как пустую строку\r\n  let R = \"\";\r\n\r\n  // 6. Устанавливаем k = 0\r\n  let k = 0;\r\n\r\n  // 7. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Если k > 0, добавляем sep к R\r\n    if (k > 0) {\r\n      R = R + sep;\r\n    }\r\n\r\n    // b. Получаем элемент по ключу k из объекта obj\r\n    let element = Get(obj, ToString(𝔽(k)));\r\n\r\n    // c. Если element равен undefined или null, устанавливаем next как пустую строку\r\n    //    Иначе, устанавливаем next как строковое представление элемента\r\n    let next = (element === undefined || element === null) ? \"\" : ToString(element);\r\n\r\n    // d. Добавляем next к R\r\n    R = R + next;\r\n\r\n    // e. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 8. Возвращаем R\r\n  return R;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If separator is undefined, let sep be \",\".\r\n4. Else, let sep be ? ToString(separator).\r\n5. Let R be the empty String.\r\n6. Let k be 0.\r\n7. Repeat, while k < len,\r\n  a. If k > 0, set R to the string-concatenation of R and sep.\r\n  b. Let element be ? Get(O, ! ToString(𝔽(k))).\r\n  c. If element is either undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).\r\n  d. Set R to the string-concatenation of R and next.\r\n  e. Set k to k + 1.\r\n8. Return R.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToString()",
          "Get()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.join",
        "title": "join()",
        "slug": "Array/join()"
      },
      "Array/keys()": {
        "content": "Метод `keys()` возвращает новый **итератор массива** `Array Iterator`, содержащий ключи каждого индекса в массиве.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = ['a', 'b', 'c'];\r\nconst iterator = arr.keys();\r\n\r\nfor (const key of iterator) {\r\n  console.log(key);\r\n}\r\n\r\n// 0\r\n// 1\r\n// 2\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.keys = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Создаем и возвращаем новый объект итератора для массива obj. \r\n  // Итератор будет возвращать ключ для каждого \r\n  // элемента в массиве. Параметр key указывает, что итератор \r\n  // должен возвращать только ключ для каждого элемента.\r\n  return CreateArrayIterator(obj, key);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Return CreateArrayIterator(O, KEY).\r\n```",
        "parsedMethods": [
          "ToObject()",
          "CreateArrayIterator()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.keys",
        "title": "keys()",
        "slug": "Array/keys()"
      },
      "Array/lastIndexOf()": {
        "content": "Метод `lastIndexOf()` возвращает последний индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет. Массив просматривается от конца к началу, начиная с индекса `fromIndex`.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];\r\n\r\nconsole.log(animals.lastIndexOf('Dodo'));\r\n// 3\r\n\r\nconsole.log(animals.lastIndexOf('Tiger'));\r\n// 1\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.lastIndexOf = function(searchElement, fromIndex) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если длина массива равна 0, возвращаем -1\r\n  if (len === 0) {\r\n    return -1;\r\n  }\r\n\r\n  // 4. Если задан fromIndex, преобразуем его в целое число (или бесконечность)\r\n  //    Иначе устанавливаем n = len - 1\r\n  let n = (fromIndex !== undefined) ? ToIntegerOrInfinity(fromIndex) : (len - 1);\r\n\r\n  // 5. Если n = -∞, возвращаем -1\r\n  if (n === -Infinity) {\r\n    return -1;\r\n  }\r\n\r\n  // 6. Если n ≥ 0, устанавливаем k = min(n, len - 1)\r\n  // 7. Иначе устанавливаем k = len + n\r\n  let k = (n >= 0) ? Math.min(n, len - 1) : (len + n);\r\n\r\n  // 8. Пока k ≥ 0\r\n  while (k >= 0) {\r\n    // a. Проверяем, есть ли свойство с ключом k в объекте obj\r\n    let kPresent = HasProperty(obj, ToString(𝔽(k)));\r\n\r\n    // b. Если свойство существует\r\n    if (kPresent) {\r\n      // i. Получаем значение элемента с ключом k\r\n      let elementK = Get(obj, ToString(𝔽(k)));\r\n\r\n      // ii. Если searchElement строго равен elementK, возвращаем k\r\n      if (IsStrictlyEqual(searchElement, elementK)) {\r\n        return 𝔽(k);\r\n      }\r\n    }\r\n\r\n    // c. Уменьшаем k на 1\r\n    k = k - 1;\r\n  }\r\n\r\n  // 9. Если не найдено, возвращаем -1\r\n  return -1;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If len = 0, return -1𝔽.\r\n4. If fromIndex is present, let n be ? ToIntegerOrInfinity(fromIndex); else let n be len - 1.\r\n5. If n = -∞, return -1𝔽.\r\n6. If n ≥ 0, then\r\n  a. Let k be min(n, len - 1).\r\n7. Else,\r\n  a. Let k be len + n.\r\n8. Repeat, while k ≥ 0,\r\n  a. Let kPresent be ? HasProperty(O, ! ToString(𝔽(k))).\r\n  b. If kPresent is true, then\r\n    i. Let elementK be ? Get(O, ! ToString(𝔽(k))).\r\n    ii. If IsStrictlyEqual(searchElement, elementK) is true, return 𝔽(k).\r\n  c. Set k to k - 1.\r\n9. Return -1𝔽.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "HasProperty()",
          "ToString()",
          "Get()",
          "IsStrictlyEqual()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.lastindexof",
        "title": "lastIndexOf()",
        "slug": "Array/lastIndexOf()"
      },
      "Array/map()": {
        "content": "Метод `map()` создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst numbers = [1, 4, 9];\r\nconst roots = numbers.map(Math.sqrt);\r\n// roots = [1, 2, 3]\r\n// numbers = [1, 4, 9]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n\r\n// this = arr\r\nArray.prototype.map = function(callbackfn, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта O\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError(\"callbackfn is not a function\");\r\n  }\r\n\r\n  // 4. Создаем новый массив A с использованием ArraySpeciesCreate\r\n  let A = ArraySpeciesCreate(obj, len);\r\n\r\n  // 5. Устанавливаем начальное значение k в 0\r\n  let k = 0;\r\n\r\n  // 6. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковое представление k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, существует ли свойство с ключом Pk в объекте obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство существует, то\r\n    if (kPresent === true) {\r\n      // i. Получаем значение свойства Pk\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Вызываем callbackfn с параметрами kValue, 𝔽(k), obj\r\n      let mappedValue = Call(callbackfn, thisArg, [kValue, 𝔽(k), obj]);\r\n\r\n      // iii. Создаем или изменяем свойство Pk в массиве A с значением mappedValue\r\n      CreateDataPropertyOrThrow(A, Pk, mappedValue);\r\n    }\r\n\r\n    // d. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 7. Возвращаем новый массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. Let A be ? ArraySpeciesCreate(O, len).\r\n5. Let k be 0.\r\n6. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Let mappedValue be ? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »).\r\n    iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).\r\n  d. Set k to k + 1.\r\n7. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ArraySpeciesCreate()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Call()",
          "CreateDataPropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map",
        "title": "map()",
        "slug": "Array/map()"
      },
      "Array/pop()": {
        "content": "Метод `pop()` удаляет последний элемент из массива и возвращает его значение.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst nums = [1, 2, 3, 4];\r\n\r\nconsole.log(nums); // [1, 2, 3, 4]\r\n\r\nconst popped = nums.pop();\r\n\r\nconsole.log(myFish); // [1, 2, 3]\r\n\r\nconsole.log(popped); // 4\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// this = arr\r\nArray.prototype.pop = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если длина массива равна 0, устанавливаем длину в 0 и возвращаем undefined\r\n  if (len === 0) {\r\n    Set(obj, \"length\", +0𝔽, true);\r\n    return undefined;\r\n  }\r\n\r\n  // 4. Уменьшаем длину массива на 1\r\n  let newLen = 𝔽(len - 1);\r\n\r\n  // 5. Получаем индекс удаляемого элемента\r\n  let index = ToString(newLen);\r\n\r\n  // 6. Получаем значение удаляемого элемента\r\n  let element = Get(obj, index);\r\n\r\n  // 7. Удаляем свойство с полученным индексом\r\n  DeletePropertyOrThrow(obj, index);\r\n\r\n  // 8. Устанавливаем новую длину массива\r\n  Set(obj, \"length\", newLen, true);\r\n\r\n  // 9. Возвращаем удаленный элемент\r\n  return element;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If len = 0, then\r\n  a. Perform ? Set(O, \"length\", +0𝔽, true).\r\n  b. Return undefined.\r\n4. Else,\r\n  a. Assert: len > 0.\r\n  b. Let newLen be 𝔽(len - 1).\r\n  c. Let index be ! ToString(newLen).\r\n  d. Let element be ? Get(O, index).\r\n  e. Perform ? DeletePropertyOrThrow(O, index).\r\n  f. Perform ? Set(O, \"length\", newLen, true).\r\n  g. Return element.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "Set()",
          "ToString()",
          "Get()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(1)",
            "color": "green"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.pop",
        "title": "pop()",
        "slug": "Array/pop()"
      },
      "Array/push()": {
        "content": "Метод `push()` добавляет один или более элементов в конец массива и возвращает **новую длину** массива.\r\n\r\nКогда мы используем `push()` для добавления нескольких элементов в конец массива, это может занять дополнительную память. Если текущая длина массива не достаточна для хранения всех новых элементов, то может потребоваться выделение дополнительной памяти.\r\n\r\nВ большинстве современных движков JavaScript такие операции управления памятью автоматизированы, и они заботятся о расширении массива и выделении необходимой памяти. Как следствие, сложность по памяти для метода `push()` остается амортизированной `O(1)` в среднем случае, но иногда может возникнуть необходимость в выделении дополнительной памяти, что приведет к временным затратам.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst nums = [1, 2];\r\nconst total = nums.push(3, 4);\r\n\r\nconsole.log(sports); // [1, 2, 3, 4]\r\nconsole.log(total); // 4\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = items.length\r\n\r\n// this = arr\r\nArray.prototype.push = function (...items) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Получаем количество элементов в аргументах (items)\r\n  let argCount = items.length;\r\n\r\n  // 4. Если сумма len и argCount больше 2^53 - 1, выбрасываем исключение TypeError\r\n  if (len + argCount > 2**53 - 1) {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 5. Для каждого элемента E в аргументах items делаем следующее:\r\n  for (let E of items) {\r\n    // a. Устанавливаем в obj значение E по ключу,\r\n    // равному текущей длине len (преобразованной в строку)\r\n    Set(obj, ToString(𝔽(len)), E, true);\r\n    \r\n    // b. Увеличиваем len на 1\r\n    len = len + 1;\r\n  }\r\n\r\n  // 6. Устанавливаем в obj значение \"length\"\r\n  // равным новой длине len (преобразованной в строку)\r\n  Set(obj, \"length\", 𝔽(len), true);\r\n\r\n  // 7. Возвращаем новую длину массива в виде числа\r\n  return 𝔽(len);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let argCount be the number of elements in items.\r\n4. If len + argCount > 2**53 - 1, throw a TypeError exception.\r\n5. For each element E of items, do\r\n  a. Perform ? Set(O, ! ToString(𝔽(len)), E, true).\r\n  b. Set len to len + 1.\r\n6. Perform ? Set(O, \"length\", 𝔽(len), true).\r\n7. Return 𝔽(len).\r\n```",
        "parsedMethods": [
          "O()",
          "ToObject()",
          "LengthOfArrayLike()",
          "TypeError()",
          "Set()",
          "ToString()"
        ],
        "tc": {
          "best": {
            "title": "O(1)",
            "color": "green"
          },
          "average": {
            "title": "O(1)",
            "color": "green"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push",
        "title": "push()",
        "slug": "Array/push()"
      },
      "Array/reduce()": {
        "content": "Метод `reduce()` применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2, 3, 4];\r\n\r\n// 0 + 1 + 2 + 3 + 4\r\narr.reduce(function (accumulator, currentValue, index, array) {\r\n  return accumulator + currentValue;\r\n}, 0);\r\n\r\nconsole.log(sumWithInitial);\r\n// 10\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n// m = accumulator\r\n\r\n// this = arr\r\nArray.prototype.reduce = function(callbackfn, initialValue) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError('callbackfn is not a function');\r\n  }\r\n\r\n  // 4. Если массив пуст и initialValue отсутствует, выбрасываем исключение\r\n  if (len === 0 && !initialValue) {\r\n    throw new TypeError('Reduce of empty array with no initial value');\r\n  }\r\n\r\n  // 5. Устанавливаем начальное значение индекса k в 0\r\n  let k = 0;\r\n\r\n  // 6. Инициализируем аккумулятор значением undefined\r\n  let accumulator = undefined;\r\n\r\n  // 7. Если присутствует initialValue, устанавливаем аккумулятор в initialValue\r\n  if (initialValue !== undefined) {\r\n    accumulator = initialValue;\r\n  } else {\r\n    // 8. Иначе, ищем первый существующий индекс в obj и устанавливаем аккумулятор\r\n    let kPresent = false;\r\n    while (!kPresent && k < len) {\r\n      let Pk = ToString(𝔽(k));\r\n      kPresent = HasProperty(obj, Pk);\r\n      if (kPresent) {\r\n        accumulator = Get(obj, Pk);\r\n      }\r\n      k++;\r\n    }\r\n    // Если такого индекса не найдено, выбрасываем исключение\r\n    if (!kPresent) {\r\n      throw new TypeError('Reduce of empty array with no initial value');\r\n    }\r\n  }\r\n\r\n  // 9. Перебираем элементы массива и применяем callbackfn\r\n  while (k < len) {\r\n    let Pk = ToString(𝔽(k));\r\n    let kPresent = HasProperty(obj, Pk);\r\n    if (kPresent) {\r\n      let kValue = Get(obj, Pk);\r\n      accumulator = Call(callbackfn, undefined, [accumulator, kValue, 𝔽(k), obj]);\r\n    }\r\n    k++;\r\n  }\r\n\r\n  // 10. Возвращаем итоговое значение аккумулятора\r\n  return accumulator;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. If len = 0 and initialValue is not present, throw a TypeError exception.\r\n5. Let k be 0.\r\n6. Let accumulator be undefined.\r\n7. If initialValue is present, then\r\n  a. Set accumulator to initialValue.\r\n8. Else,\r\n  a. Let kPresent be false.\r\n  b. Repeat, while kPresent is false and k < len,\r\n    i. Let Pk be ! ToString(𝔽(k)).\r\n    ii. Set kPresent to ? HasProperty(O, Pk).\r\n    iii. If kPresent is true, then\r\n      1. Set accumulator to ? Get(O, Pk).\r\n    iv. Set k to k + 1.\r\n  c. If kPresent is false, throw a TypeError exception.\r\n9. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Set accumulator to ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »).\r\n  d. Set k to k + 1.\r\n10. Return accumulator.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(m)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce",
        "title": "reduce()",
        "slug": "Array/reduce()"
      },
      "Array/reduceRight()": {
        "content": "Метод `reduceRight()` применяет функцию к аккумулятору и каждому значению массива (справа-налево), сводя его к одному значению.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2, 3, 4];\r\n\r\n// 0 + 1 + 2 + 3 + 4\r\narr.reduceRight(function (accumulator, currentValue, index, array) {\r\n  return accumulator + currentValue;\r\n}, 0);\r\n\r\nconsole.log(sumWithInitial);\r\n// 10\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n// m = accumulator\r\n\r\n// this = arr\r\nArray.prototype.reduceRight = function(callbackfn, initialValue) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError('callbackfn is not a function');\r\n  }\r\n\r\n  // 4. Если массив пуст и initialValue отсутствует, выбрасываем исключение\r\n  if (len === 0 && !initialValue) {\r\n    throw new TypeError('Reduce of empty array with no initial value');\r\n  }\r\n\r\n  // 5. Устанавливаем начальное значение индекса k в len - 1\r\n  let k = len - 1;\r\n\r\n  // 6. Инициализируем аккумулятор значением undefined\r\n  let accumulator = undefined;\r\n\r\n  // 7. Если присутствует initialValue, устанавливаем аккумулятор в initialValue\r\n  if (initialValue !== undefined) {\r\n    accumulator = initialValue;\r\n  } else {\r\n    // 8. Иначе, ищем последний существующий индекс в obj и устанавливаем аккумулятор\r\n    let kPresent = false;\r\n    while (!kPresent && k >= 0) {\r\n      let Pk = ToString(𝔽(k));\r\n      kPresent = HasProperty(obj, Pk);\r\n      if (kPresent) {\r\n        accumulator = Get(obj, Pk);\r\n      }\r\n      k--;\r\n    }\r\n    // Если такого индекса не найдено, выбрасываем исключение\r\n    if (!kPresent) {\r\n      throw new TypeError('Reduce of empty array with no initial value');\r\n    }\r\n  }\r\n\r\n  // 9. Перебираем элементы массива в обратном порядке и применяем callbackfn\r\n  while (k >= 0) {\r\n    let Pk = ToString(𝔽(k));\r\n    let kPresent = HasProperty(obj, Pk);\r\n    if (kPresent) {\r\n      let kValue = Get(obj, Pk);\r\n      accumulator = Call(callbackfn, undefined, [accumulator, kValue, 𝔽(k), obj]);\r\n    }\r\n    k--;\r\n  }\r\n\r\n  // 10. Возвращаем итоговое значение аккумулятора\r\n  return accumulator;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. If len = 0 and initialValue is not present, throw a TypeError exception.\r\n5. Let k be len - 1.\r\n6. Let accumulator be undefined.\r\n7. If initialValue is present, then\r\n  a. Set accumulator to initialValue.\r\n8. Else,\r\n  a. Let kPresent be false.\r\n  b. Repeat, while kPresent is false and k ≥ 0,\r\n    i. Let Pk be ! ToString(𝔽(k)).\r\n    ii. Set kPresent to ? HasProperty(O, Pk).\r\n    iii. If kPresent is true, then\r\n      1. Set accumulator to ? Get(O, Pk).\r\n    iv. Set k to k - 1.\r\n  c. If kPresent is false, throw a TypeError exception.\r\n9. Repeat, while k ≥ 0,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Set accumulator to ? Call(callbackfn, undefined, « accumulator, kValue, 𝔽(k), O »).\r\n  d. Set k to k - 1.\r\n10. Return accumulator.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(m)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduceright",
        "title": "reduceRight()",
        "slug": "Array/reduceRight()"
      },
      "Array/reverse()": {
        "content": "Метод `reverse()` на месте обращает порядок следования элементов массива. Первый элемент массива становится последним, а последний — первым.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst array1 = [1, 2, 3];\r\nconsole.log('array1:', array1);\r\n// [1, 2, 3]\r\n\r\nconst reversed = array1.reverse();\r\nconsole.log('reversed:', reversed);\r\n// [3, 2, 1]\r\n\r\n// Меняется и оригинальный массив\r\nconsole.log('array1:', array1);\r\n// [3, 2, 1]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.reverse = function () {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Вычисляем середину массива\r\n  let middle = Math.floor(len / 2);\r\n\r\n  // 4. Устанавливаем начальное значение lower в 0\r\n  let lower = 0;\r\n\r\n  // 5. Повторяем, пока lower не станет равным middle\r\n  while (lower !== middle) {\r\n    // a. Вычисляем upper и upperP\r\n    let upper = len - lower - 1;\r\n    let upperP = ToString(𝔽(upper));\r\n\r\n    // b. Вычисляем lowerP\r\n    let lowerP = ToString(𝔽(lower));\r\n\r\n    // c. Проверяем, существует ли свойство с ключом lowerP в объекте obj\r\n    let lowerExists = HasProperty(obj, lowerP);\r\n\r\n    // d. Если свойство существует, получаем его значение\r\n    if (lowerExists) {\r\n      let lowerValue = Get(obj, lowerP);\r\n    }\r\n\r\n    // e. Проверяем, существует ли свойство с ключом upperP в объекте obj\r\n    let upperExists = HasProperty(obj, upperP);\r\n\r\n    // f. Если свойство существует, получаем его значение\r\n    if (upperExists) {\r\n      let upperValue = Get(obj, upperP);\r\n    }\r\n\r\n    // h. Если оба свойства существуют, меняем их значения местами\r\n    if (lowerExists && upperExists) {\r\n      Set(obj, lowerP, upperValue, true);\r\n      Set(obj, upperP, lowerValue, true);\r\n    }\r\n    // i. Если только нижнее свойство существует, устанавливаем его значение на место верхнего и удаляем верхнее свойство\r\n    else if (!lowerExists && upperExists) {\r\n      Set(obj, lowerP, upperValue, true);\r\n      DeletePropertyOrThrow(obj, upperP);\r\n    }\r\n    // j. Если только верхнее свойство существует, удаляем нижнее свойство и устанавливаем значение верхнего на его место\r\n    else if (lowerExists && !upperExists) {\r\n      DeletePropertyOrThrow(obj, lowerP);\r\n      Set(obj, upperP, lowerValue, true);\r\n    }\r\n    // k. Если оба свойства отсутствуют, ничего не делаем\r\n    else {\r\n      // Нет необходимости в дополнительных действиях\r\n    }\r\n\r\n    // l. Увеличиваем lower на 1\r\n    lower = lower + 1;\r\n  }\r\n\r\n  // 6. Возвращаем измененный объект\r\n  return obj;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let middle be floor(len / 2).\r\n4. Let lower be 0.\r\n5. Repeat, while lower ≠ middle,\r\n  a. Let upper be len - lower - 1.\r\n  b. Let upperP be ! ToString(𝔽(upper)).\r\n  c. Let lowerP be ! ToString(𝔽(lower)).\r\n  d. Let lowerExists be ? HasProperty(O, lowerP).\r\n  e. If lowerExists is true, then\r\n    i. Let lowerValue be ? Get(O, lowerP).\r\n  f. Let upperExists be ? HasProperty(O, upperP).\r\n  g. If upperExists is true, then\r\n    i. Let upperValue be ? Get(O, upperP).\r\n  h. If lowerExists is true and upperExists is true, then\r\n    i. Perform ? Set(O, lowerP, upperValue, true).\r\n    ii. Perform ? Set(O, upperP, lowerValue, true).\r\n  i. Else if lowerExists is false and upperExists is true, then\r\n    i. Perform ? Set(O, lowerP, upperValue, true).\r\n    ii. Perform ? DeletePropertyOrThrow(O, upperP).\r\n  j. Else if lowerExists is true and upperExists is false, then\r\n    i. Perform ? DeletePropertyOrThrow(O, lowerP).\r\n    ii. Perform ? Set(O, upperP, lowerValue, true).\r\n  k. Else,\r\n    i. Assert: lowerExists and upperExists are both false.\r\n    ii. NOTE: No action is required.\r\n  l. Set lower to lower + 1.\r\n6. Return O.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Set()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reverse",
        "title": "reverse()",
        "slug": "Array/reverse()"
      },
      "Array/shift()": {
        "content": "Метод `shift()` удаляет первый элемент из массива и возвращает его значение. Этот метод изменяет длину массива.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst nums = [1, 2, 3, 4];\r\n\r\nconsole.log(nums);\r\n// [1, 2, 3, 4]\r\n\r\nconst shifted = nums.shift();\r\n\r\nconsole.log(nums);\r\n// [2, 3, 4]\r\n\r\nconsole.log(shifted);\r\n// 1\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.shift = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Если len = 0, устанавливаем длину массива в 0 и возвращаем undefined\r\n  if (len === 0) {\r\n    Set(obj, \"length\", +0𝔽, true);\r\n    return undefined;\r\n  }\r\n\r\n  // 4. Получаем значение первого элемента массива\r\n  let first = Get(obj, \"0\");\r\n\r\n  // 5. Устанавливаем начальное значение для индекса k\r\n  let k = 1;\r\n\r\n  // 6. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковые представления индексов from и to\r\n    let from = ToString(𝔽(k));\r\n    let to = ToString(𝔽(k - 1));\r\n\r\n    // b. Проверяем, есть ли свойство с индексом from\r\n    let fromPresent = HasProperty(O, from);\r\n\r\n    // c. Если свойство с индексом from существует\r\n    if (fromPresent) {\r\n      // i. Получаем значение свойства from\r\n      let fromVal = Get(obj, from);\r\n      // ii. Устанавливаем значение свойства to равным fromVal\r\n      Set(obj, to, fromVal, true);\r\n    } else {\r\n      // e. Если свойства с индексом from нет, удаляем свойство to\r\n      DeletePropertyOrThrow(obj, to);\r\n    }\r\n\r\n    // f. Увеличиваем значение k\r\n    k = k + 1;\r\n  }\r\n\r\n  // 7. Удаляем последний элемент массива\r\n  DeletePropertyOrThrow(obj, ToString(𝔽(len - 1)));\r\n\r\n  // 8. Устанавливаем новую длину массива (len - 1)\r\n  Set(obj, \"length\", 𝔽(len - 1), true);\r\n\r\n  // 9. Возвращаем значение первого элемента массива\r\n  return first;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If len = 0, then\r\n  a. Perform ? Set(O, \"length\", +0𝔽, true).\r\n  b. Return undefined.\r\n4. Let first be ? Get(O, \"0\").\r\n5. Let k be 1.\r\n6. Repeat, while k < len,\r\n  a. Let from be ! ToString(𝔽(k)).\r\n  b. Let to be ! ToString(𝔽(k - 1)).\r\n  c. Let fromPresent be ? HasProperty(O, from).\r\n  d. If fromPresent is true, then\r\n    i. Let fromVal be ? Get(O, from).\r\n    ii. Perform ? Set(O, to, fromVal, true).\r\n  e. Else,\r\n    i. Assert: fromPresent is false.\r\n    ii. Perform ? DeletePropertyOrThrow(O, to).\r\n  f. Set k to k + 1.\r\n7. Perform ? DeletePropertyOrThrow(O, ! ToString(𝔽(len - 1))).\r\n8. Perform ? Set(O, \"length\", 𝔽(len - 1), true).\r\n9. Return first.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "Set()",
          "Get()",
          "ToString()",
          "HasProperty()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.shift",
        "title": "shift()",
        "slug": "Array/shift()"
      },
      "Array/slice()": {
        "content": "Метод `slice()` возвращает новый массив, содержащий копию части исходного массива.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];\r\n\r\nconsole.log(animals.slice(2));\r\n// [\"camel\", \"duck\", \"elephant\"]\r\n\r\nconsole.log(animals.slice(2, 4));\r\n// [\"camel\", \"duck\"]\r\n\r\nconsole.log(animals.slice(1, 5));\r\n// [\"bison\", \"camel\", \"duck\", \"elephant\"]\r\n\r\nconsole.log(animals.slice(-2));\r\n// [\"duck\", \"elephant\"]\r\n\r\nconsole.log(animals.slice(2, -1));\r\n// [\"camel\", \"duck\"]\r\n\r\nconsole.log(animals.slice());\r\n// [\"ant\", \"bison\", \"camel\", \"duck\", \"elephant\"]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = count\r\n\r\n// this = arr\r\nArray.prototype.slice = function(start, end) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем начальный индекс в целое число (или бесконечность)\r\n  let relativeStart = ToIntegerOrInfinity(start);\r\n\r\n  // 4. Если relativeStart = -∞, устанавливаем k\r\n  let k = (relativeStart === -Infinity) ? 0 : (relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len));\r\n\r\n  // 7. Если конечный индекс не определен, устанавливаем relativeEnd в len, иначе преобразуем его в целое число\r\n  let relativeEnd = (end === undefined) ? len : ToIntegerOrInfinity(end);\r\n\r\n  // 8. Если relativeEnd = -∞, устанавливаем final в 0\r\n  let final = (relativeEnd === -Infinity) ? 0 : (relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len));\r\n\r\n  // 11. Вычисляем количество элементов в подмассиве\r\n  let count = Math.max(final - k, 0);\r\n\r\n  // 12. Создаем новый массив A\r\n  let A = ArraySpeciesCreate(obj, count);\r\n\r\n  // 13. Инициализируем счетчик n\r\n  let n = 0;\r\n\r\n  // 14. Копируем элементы из obj в массив A\r\n  while (k < final) {\r\n    // a. Получаем строковый ключ Pk\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, присутствует ли свойство с ключом Pk в obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство присутствует, копируем его в массив A\r\n    if (kPresent) {\r\n      // i. Получаем значение свойства по ключу Pk\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Устанавливаем значение в массив A по ключу n\r\n      CreateDataPropertyOrThrow(A, ToString(𝔽(n)), kValue);\r\n    }\r\n\r\n    // d. Увеличиваем счетчики k и n\r\n    k = k + 1;\r\n    n = n + 1;\r\n  }\r\n\r\n  // 15. Устанавливаем длину массива A\r\n  Set(A, \"length\", 𝔽(n), true);\r\n\r\n  // 16. Возвращаем массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeStart be ? ToIntegerOrInfinity(start).\r\n4. If relativeStart = -∞, let k be 0.\r\n5. Else if relativeStart < 0, let k be max(len + relativeStart, 0).\r\n6. Else, let k be min(relativeStart, len).\r\n7. If end is undefined, let relativeEnd be len; else let relativeEnd be ? ToIntegerOrInfinity(end).\r\n8. If relativeEnd = -∞, let final be 0.\r\n9. Else if relativeEnd < 0, let final be max(len + relativeEnd, 0).\r\n10. Else, let final be min(relativeEnd, len).\r\n11. Let count be max(final - k, 0).\r\n12. Let A be ? ArraySpeciesCreate(O, count).\r\n13. Let n be 0.\r\n14. Repeat, while k < final,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(n)), kValue).\r\n  d. Set k to k + 1.\r\n  e. Set n to n + 1.\r\n15. Perform ? Set(A, \"length\", 𝔽(n), true).\r\n16. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "ArraySpeciesCreate()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "CreateDataPropertyOrThrow()",
          "Set()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.slice",
        "title": "slice()",
        "slug": "Array/slice()"
      },
      "Array/some()": {
        "content": "Метод `some()` проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst array = [1, 2, 3, 4, 5];\r\n\r\nconst even = (element) => element % 2 === 0;\r\n\r\nconsole.log(array.some(even));\r\n// true\r\n\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n// k = callbackfn\r\n\r\n// this = arr\r\nArray.prototype.some = function(callbackfn, thisArg) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Проверяем, является ли callbackfn вызываемой функцией\r\n  if (IsCallable(callbackfn) === false) {\r\n    throw new TypeError('callbackfn is not a function');\r\n  }\r\n\r\n  // 4. Устанавливаем начальное значение индекса k\r\n  let k = 0;\r\n\r\n  // 5. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковый ключ Pk для текущего индекса k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Проверяем, есть ли свойство с ключом Pk в объекте obj\r\n    let kPresent = HasProperty(obj, Pk);\r\n\r\n    // c. Если свойство существует, выполняем следующие шаги\r\n    if (kPresent) {\r\n      // i. Получаем значение элемента по ключу Pk\r\n      let kValue = Get(obj, Pk);\r\n\r\n      // ii. Вызываем callbackfn с передачей текущего значения, индекса и объекта\r\n      let testResult = ToBoolean(Call(callbackfn, thisArg, [kValue, 𝔽(k), obj]));\r\n\r\n      // iii. Если результат callbackfn равен true, возвращаем true\r\n      if (testResult) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // d. Увеличиваем индекс k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 6. Если не найден элемент, для которого callbackfn возвращает true, возвращаем false\r\n  return false;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. If IsCallable(callbackfn) is false, throw a TypeError exception.\r\n4. Let k be 0.\r\n5. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. Let kPresent be ? HasProperty(O, Pk).\r\n  c. If kPresent is true, then\r\n    i. Let kValue be ? Get(O, Pk).\r\n    ii. Let testResult be ToBoolean(? Call(callbackfn, thisArg, « kValue, 𝔽(k), O »)).\r\n    iii. If testResult is true, return true.\r\n  d. Set k to k + 1.\r\n6. Return false.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "IsCallable()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "ToBoolean()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.some",
        "title": "some()",
        "slug": "Array/some()"
      },
      "Array/sort()": {
        "content": "Метод `sort()` на месте сортирует элементы массива и возвращает отсортированный массив. Сортировка не обязательно [устойчива](https://ru.wikipedia.org/wiki/Устойчивая_сортировка). Порядок сортировки по умолчанию соответствует порядку кодовых точек Unicode.\r\n\r\nВ JavaScript, метод `sort()` для массивов использует алгоритм сортировки, который обычно является алгоритмом сортировки слиянием (Merge Sort) или быстрой сортировки (Quick Sort). Оба эти алгоритма имеют временную сложность `O(n log(n))` в среднем случае.\r\n\r\nВ спецификации ECMAScript не определено конкретное требование к реализации метода `sort()`. Различные JavaScript-движки могут использовать разные стратегии сортировки в зависимости от размера массива и других факторов.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst fruit = [\"арбузы\", \"бананы\", \"Вишня\"];\r\nfruit.sort(); // ['Вишня', 'арбузы', 'бананы']\r\n\r\nconst scores = [1, 2, 10, 21];\r\nscores.sort(); // [1, 10, 2, 21]\r\n\r\nconst things = [\"слово\", \"Слово\", \"1 Слово\", \"2 Слова\"];\r\nthings.sort(); // ['1 Слово', '2 Слова', 'Слово', 'слово']\r\n// В Unicode, числа находятся перед буквами в верхнем регистре,\r\n// а те, в свою очередь, перед буквами в нижнем регистре.\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.sort = function(comparefn) {\r\n  // 1. Если comparefn не определен или не является функцией, выбрасываем исключение TypeError\r\n  if (comparefn !== undefined && !IsCallable(comparefn)) {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 2. Преобразуем this в объект, если необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 3. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 4. Создаем замыкание SortCompare\r\n  let SortCompare = function(x, y) {\r\n    return CompareArrayElements(x, y, comparefn);\r\n  };\r\n\r\n  // 5. Сортируем свойства массива obj с использованием замыкания SortCompare и SKIP-HOLES\r\n  let sortedList = SortIndexedProperties(obj, len, SortCompare, SKIP-HOLES);\r\n\r\n  // 6. Получаем количество элементов в отсортированном списке\r\n  let itemCount = sortedList.length;\r\n\r\n  // 7. Инициализируем индекс j\r\n  let j = 0;\r\n\r\n  // 8. Копируем отсортированные элементы обратно в массив obj\r\n  while (j < itemCount) {\r\n    // a. Устанавливаем значение на позицию j в массиве obj\r\n    Set(obj, ToString(𝔽(j)), sortedList[j], true);\r\n\r\n    // b. Увеличиваем индекс j\r\n    j = j + 1;\r\n  }\r\n\r\n  // 9. Удаляем лишние свойства, если они есть\r\n  // (остались после сортировки)\r\n  while (j < len) {\r\n    // a. Удаляем свойство на позиции j\r\n    DeletePropertyOrThrow(obj, ToString(𝔽(j)));\r\n\r\n    // b. Увеличиваем индекс j\r\n    j = j + 1;\r\n  }\r\n\r\n  // 10. Возвращаем отсортированный массив obj\r\n  return obj;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. If comparefn is not undefined and IsCallable(comparefn) is false, throw a TypeError exception.\r\n2. Let obj be ? ToObject(this value).\r\n3. Let len be ? LengthOfArrayLike(obj).\r\n4. Let SortCompare be a new Abstract Closure with parameters (x, y) that captures comparefn and performs the following steps when called:\r\n  a. Return ? CompareArrayElements(x, y, comparefn).\r\n5. Let sortedList be ? SortIndexedProperties(obj, len, SortCompare, SKIP-HOLES).\r\n6. Let itemCount be the number of elements in sortedList.\r\n7. Let j be 0.\r\n8. Repeat, while j < itemCount,\r\n  a. Perform ? Set(obj, ! ToString(𝔽(j)), sortedList[j], true).\r\n  b. Set j to j + 1.\r\n9. NOTE: The call to SortIndexedProperties in step 5 uses SKIP-HOLES. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.\r\n10. Repeat, while j < len,\r\n  a. Perform ? DeletePropertyOrThrow(obj, ! ToString(𝔽(j))).\r\n  b. Set j to j + 1.\r\n11. Return obj.\r\n```",
        "parsedMethods": [
          "O()",
          "IsCallable()",
          "TypeError()",
          "ToObject()",
          "LengthOfArrayLike()",
          "CompareArrayElements()",
          "SortIndexedProperties()",
          "Set()",
          "ToString()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "average": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n²)",
            "color": "red"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.sort",
        "title": "sort()",
        "slug": "Array/sort()"
      },
      "Array/splice()": {
        "content": "Метод `splice()` изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые. Возвращает массив удаленных элементов.\r\n\r\n##### Использование\r\n\r\n```js\r\n// Удаляет 0 элементов по индексу 2 и вставляет цифру 3\r\nconst nums = [1, 2, 4, 5];\r\nconst removed = nums.splice(2, 0, 3);\r\n// nums = [1, 2, 3, 4, 5]\r\n// removed = [], ничего не удалено\r\n\r\n// Удаляет 1 элемент по индексу 3\r\nconst nums = [1, 2, 3, 4, 5];\r\nconst removed = nums.splice(3, 1);\r\n// nums = [1, 2, 3, 5]\r\n// removed = [4]\r\n\r\n// Удаляет 1 элемент по индексу 2 и вставляет цифру 3\r\nconst nums = [1, 2, 4, 5];\r\nconst removed = nums.splice(2, 1, 3);\r\n// nums = [1, 2, 3, 5]\r\n// removed = [4]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length + items.length\r\n// k = actualDeleteCount\r\n\r\n// this = arr\r\nArray.prototype.splice = function(start, deleteCount, ...items) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем полученный индекс start в целое число (или бесконечность)\r\n  let relativeStart = ToIntegerOrInfinity(start);\r\n\r\n  // 4. Если relativeStart = -∞, устанавливаем actualStart = 0\r\n  // 5. Иначе, если relativeStart < 0, устанавливаем actualStart = max(len + relativeStart, 0)\r\n  // 6. Иначе, устанавливаем actualStart = min(relativeStart, len)\r\n  let actualStart = (relativeStart === -Infinity) ? 0 : ((relativeStart < 0) ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len));\r\n\r\n  // 7. Получаем количество элементов в items\r\n  let itemCount = items.length;\r\n\r\n  // 8. Если start отсутствует, устанавливаем actualDeleteCount = 0\r\n  // 9. Иначе, если deleteCount отсутствует, устанавливаем actualDeleteCount = len - actualStart\r\n  // 10. Иначе, устанавливаем actualDeleteCount = clamp(deleteCount, 0, len - actualStart)\r\n  let actualDeleteCount = (start === undefined) ? 0 :\r\n    ((deleteCount === undefined) ? (len - actualStart) : Math.min(Math.max(ToIntegerOrInfinity(deleteCount), 0), len - actualStart));\r\n\r\n  // 11. Если len + itemCount - actualDeleteCount > 2**53 - 1, выбрасываем исключение TypeError\r\n  if (len + itemCount - actualDeleteCount > 2 ** 53 - 1) {\r\n    throw new TypeError();\r\n  }\r\n\r\n  // 12. Создаем новый массив A с использованием ArraySpeciesCreate\r\n  let A = ArraySpeciesCreate(obj, actualDeleteCount);\r\n\r\n  // 13. Устанавливаем k = 0\r\n  let k = 0;\r\n\r\n  // 14. Повторяем, пока k < actualDeleteCount\r\n  while (k < actualDeleteCount) {\r\n    // a. Получаем значение ключа from из объекта obj\r\n    let from = ToString(𝔽(actualStart + k));\r\n    // b. Если свойство from существует в объекте obj, то\r\n    if (HasProperty(obj, from)) {\r\n      // i. Получаем значение свойства from из объекта obj\r\n      let fromValue = Get(obj, from);\r\n      // ii. Устанавливаем значение свойства с ключом k в массиве A\r\n      //    равным fromValue\r\n      CreateDataPropertyOrThrow(A, ToString(𝔽(k)), fromValue);\r\n    }\r\n    // c. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 15. Устанавливаем длину массива A в actualDeleteCount\r\n  Set(A, \"length\", 𝔽(actualDeleteCount), true);\r\n\r\n  // 16. Если itemCount < actualDeleteCount, то\r\n  if (itemCount < actualDeleteCount) {\r\n    // a. Устанавливаем k = actualStart\r\n    k = actualStart;\r\n\r\n    // b. Повторяем, пока k < (len - actualDeleteCount)\r\n    while (k < (len - actualDeleteCount)) {\r\n      // i. Получаем значение ключа from из объекта obj\r\n      let from = ToString(𝔽(k + actualDeleteCount));\r\n\r\n      // ii. Получаем значение ключа to из объекта obj\r\n      let to = ToString(𝔽(k + itemCount));\r\n\r\n      // iii. Если свойство from существует в объекте obj, то\r\n      if (HasProperty(obj, from)) {\r\n        // 1. Получаем значение свойства from из объекта obj\r\n        let fromValue = Get(obj, from);\r\n        // 2. Устанавливаем значение свойства с ключом to в объекте obj\r\n        //    равным fromValue\r\n        Set(obj, to, fromValue, true);\r\n      }\r\n      // iv. В противном случае\r\n      else {\r\n        // 1. Удаляем свойство to из объекта obj\r\n        DeletePropertyOrThrow(obj, to);\r\n      }\r\n\r\n      // v. Увеличиваем k на 1\r\n      k = k + 1;\r\n    }\r\n\r\n    // c. Устанавливаем k = len\r\n    k = len;\r\n\r\n    // d. Повторяем, пока k > (len - actualDeleteCount + itemCount)\r\n    while (k > (len - actualDeleteCount + itemCount)) {\r\n      // i. Удаляем свойство с ключом k - 1 из объекта obj\r\n      DeletePropertyOrThrow(obj, ToString(𝔽(k - 1)));\r\n\r\n      // ii. Уменьшаем k на 1\r\n      k = k - 1;\r\n    }\r\n  } else if (itemCount > actualDeleteCount) {\r\n    // 17. Иначе, если itemCount > actualDeleteCount, то\r\n    // a. Устанавливаем k = (len - actualDeleteCount)\r\n    k = len - actualDeleteCount;\r\n\r\n    // b. Повторяем, пока k > actualStart\r\n    while (k > actualStart) {\r\n      // i. Получаем значение ключа from из объекта obj\r\n      let from = ToString(𝔽(k + actualDeleteCount - 1));\r\n\r\n      // ii. Получаем значение ключа to из объекта obj\r\n      let to = ToString(𝔽(k + itemCount - 1));\r\n\r\n      // iii. Если свойство from существует в объекте obj, то\r\n      if (HasProperty(obj, from)) {\r\n        // 1. Получаем значение свойства from из объекта obj\r\n        let fromValue = Get(obj, from);\r\n        // 2. Устанавливаем значение свойства с ключом to в объекте obj\r\n        //    равным fromValue\r\n        Set(obj, to, fromValue, true);\r\n      }\r\n      // iv. В противном случае\r\n      else {\r\n        // 1. Удаляем свойство to из объекта obj\r\n        DeletePropertyOrThrow(obj, to);\r\n      }\r\n\r\n      // v. Уменьшаем k на 1\r\n      k = k - 1;\r\n    }\r\n  }\r\n\r\n  // 18. Устанавливаем k = actualStart\r\n  k = actualStart;\r\n\r\n  // 19. Для каждого элемента E из items, делаем\r\n  for (let E of items) {\r\n    // a. Устанавливаем свойство с ключом k в объекте obj равным E\r\n    Set(obj, ToString(𝔽(k)), E, true);\r\n    // b. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 20. Устанавливаем длину объекта obj в len - actualDeleteCount + itemCount\r\n  Set(obj, \"length\", 𝔽(len - actualDeleteCount + itemCount), true);\r\n\r\n  // 21. Возвращаем новый массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeStart be ? ToIntegerOrInfinity(start).\r\n4. If relativeStart = -∞, let actualStart be 0.\r\n5. Else if relativeStart < 0, let actualStart be max(len + relativeStart, 0).\r\n6. Else, let actualStart be min(relativeStart, len).\r\n7. Let itemCount be the number of elements in items.\r\n8. If start is not present, then\r\n  a. Let actualDeleteCount be 0.\r\n9. Else if deleteCount is not present, then\r\n  a. Let actualDeleteCount be len - actualStart.\r\n10. Else,\r\n  a. Let dc be ? ToIntegerOrInfinity(deleteCount).\r\n  b. Let actualDeleteCount be the result of clamping dc between 0 and len - actualStart.\r\n11. If len + itemCount - actualDeleteCount > 2**53 - 1, throw a TypeError exception.\r\n12. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).\r\n13. Let k be 0.\r\n14. Repeat, while k < actualDeleteCount,\r\n  a. Let from be ! ToString(𝔽(actualStart + k)).\r\n  b. If ? HasProperty(O, from) is true, then\r\n    i. Let fromValue be ? Get(O, from).\r\n    ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(𝔽(k)), fromValue).\r\n  c. Set k to k + 1.\r\n15. Perform ? Set(A, \"length\", 𝔽(actualDeleteCount), true).\r\n16. If itemCount < actualDeleteCount, then\r\n  a. Set k to actualStart.\r\n  b. Repeat, while k < (len - actualDeleteCount),\r\n    i. Let from be ! ToString(𝔽(k + actualDeleteCount)).\r\n    ii. Let to be ! ToString(𝔽(k + itemCount)).\r\n    iii. If ? HasProperty(O, from) is true, then\r\n      1. Let fromValue be ? Get(O, from).\r\n      2. Perform ? Set(O, to, fromValue, true).\r\n    iv. Else,\r\n      1. Perform ? DeletePropertyOrThrow(O, to).\r\n    v. Set k to k + 1.\r\n  c. Set k to len.\r\n  d. Repeat, while k > (len - actualDeleteCount + itemCount),\r\n    i. Perform ? DeletePropertyOrThrow(O, ! ToString(𝔽(k - 1))).\r\n    ii. Set k to k - 1.\r\n17. Else if itemCount > actualDeleteCount, then\r\n  a. Set k to (len - actualDeleteCount).\r\n  b. Repeat, while k > actualStart,\r\n    i. Let from be ! ToString(𝔽(k + actualDeleteCount - 1)).\r\n    ii. Let to be ! ToString(𝔽(k + itemCount - 1)).\r\n    iii. If ? HasProperty(O, from) is true, then\r\n      1. Let fromValue be ? Get(O, from).\r\n      2. Perform ? Set(O, to, fromValue, true).\r\n    iv. Else,\r\n      1. Perform ? DeletePropertyOrThrow(O, to).\r\n    v. Set k to k - 1.\r\n18. Set k to actualStart.\r\n19. For each element E of items, do\r\n  a. Perform ? Set(O, ! ToString(𝔽(k)), E, true).\r\n  b. Set k to k + 1.\r\n20. Perform ? Set(O, \"length\", 𝔽(len - actualDeleteCount + itemCount), true).\r\n21. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "TypeError()",
          "ArraySpeciesCreate()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "CreateDataPropertyOrThrow()",
          "Set()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(k)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.splice",
        "title": "splice()",
        "slug": "Array/splice()"
      },
      "Array/toLocaleString()": {
        "content": "Метод `toLocaleString()` возвращает строковое представление элементов массива. Элементы преобразуются в строки с использованием своих собственных методов `toLocaleString` и эти строки разделяются локале-зависимой строкой (например, запятой «,»).\r\n\r\n##### Использование\r\n\r\n```js\r\nconst number = 1337;\r\nconst date = new Date();\r\nconst myArr = [number, date, \"foo\"];\r\n\r\nconst str = myArr.toLocaleString();\r\n\r\nconsole.log(str);\r\n// напечатает строку с number, date, \"foo\" через запятую\r\n// date представляет собой текущую дату в виде DD.MM.YYYY hh:mm:ss,\r\n// если работает под германской локалью (de-DE) с временной зоной Европа/Берлин\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.toLocaleString = function (reserved1, reserved2) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let array = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта array\r\n  let len = LengthOfArrayLike(array);\r\n\r\n  // 3. Получаем разделитель строк, соответствующий текущей локали\r\n  /* implementation-defined list-separator String value */\r\n  let separator = \",\";\r\n\r\n  // 4. Инициализируем пустую строку R\r\n  let R = \"\";\r\n\r\n  // 5. Устанавливаем начальное значение k = 0\r\n  let k = 0;\r\n\r\n  // 6. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Если k > 0, добавляем к R разделитель\r\n    if (k > 0) {\r\n      R = R + separator;\r\n    }\r\n\r\n    // b. Получаем следующий элемент массива\r\n    let nextElement = Get(array, ToString(𝔽(k)));\r\n\r\n    // c. Если nextElement не является undefined или null, то\r\n    if (nextElement !== undefined && nextElement !== null) {\r\n      // i. Получаем строковое представление элемента, вызывая его toLocaleString\r\n      let S = ToString(Invoke(nextElement, \"toLocaleString\"));\r\n\r\n      // ii. Добавляем S к R\r\n      R = R + S;\r\n    }\r\n\r\n    // d. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 7. Возвращаем результат R\r\n  return R;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let array be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(array).\r\n3. Let separator be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as \", \").\r\n4. Let R be the empty String.\r\n5. Let k be 0.\r\n6. Repeat, while k < len,\r\n  a. If k > 0, then\r\n    i. Set R to the string-concatenation of R and separator.\r\n  b. Let nextElement be ? Get(array, ! ToString(𝔽(k))).\r\n  c. If nextElement is neither undefined nor null, then\r\n    i. Let S be ? ToString(? Invoke(nextElement, \"toLocaleString\")).\r\n    ii. Set R to the string-concatenation of R and S.\r\n  d. Set k to k + 1.\r\n7. Return R.\r\n```",
        "parsedMethods": [
          "Date()",
          "ToObject()",
          "LengthOfArrayLike()",
          "Get()",
          "ToString()",
          "Invoke()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tolocalestring",
        "title": "toLocaleString()",
        "slug": "Array/toLocaleString()"
      },
      "Array/toReversed()": {
        "content": "Метод `toReversed()` является аналогом метода `reverse()`, за исключением того, что метод `toReversed()` возвращает копию исходного массива с элементами в обратном порядке. Не изменяет исходный массив.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst items = [1, 2, 3];\r\nconsole.log(items); // [1, 2, 3]\r\n\r\nconst reversedItems = items.toReversed();\r\nconsole.log(reversedItems); // [3, 2, 1]\r\nconsole.log(items); // [1, 2, 3]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.toReversed = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Создаем новый массив A длины len\r\n  let A = ArrayCreate(len);\r\n\r\n  // 4. Устанавливаем начальное значение k в 0\r\n  let k = 0;\r\n\r\n  // 5. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковое представление индекса len - k - 1\r\n    let from = ToString(𝔽(len - k - 1));\r\n\r\n    // b. Получаем строковое представление индекса k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // c. Получаем значение элемента из объекта obj по индексу from\r\n    let fromValue = Get(obj, from);\r\n\r\n    // d. Устанавливаем новый элемент в массив A по индексу k\r\n    CreateDataPropertyOrThrow(A, Pk, fromValue);\r\n\r\n    // e. Увеличиваем k на 1\r\n    Set k to k + 1;\r\n  }\r\n\r\n  // 6. Возвращаем новый массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let A be ? ArrayCreate(len).\r\n4. Let k be 0.\r\n5. Repeat, while k < len,\r\n  a. Let from be ! ToString(𝔽(len - k - 1)).\r\n  b. Let Pk be ! ToString(𝔽(k)).\r\n  c. Let fromValue be ? Get(O, from).\r\n  d. Perform ! CreateDataPropertyOrThrow(A, Pk, fromValue).\r\n  e. Set k to k + 1.\r\n6. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ArrayCreate()",
          "ToString()",
          "Get()",
          "CreateDataPropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.toreversed",
        "title": "toReversed()",
        "slug": "Array/toReversed()"
      },
      "Array/toSorted()": {
        "content": "Метод `toSorted()` является аналогом метода `sort()`, за исключением того, что метод `toSorted()` возвращает копию исходного массива с отсортированными элементами в порядке возрастания. Не изменяет исходный массив.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst months = [\"Mar\", \"Jan\", \"Feb\", \"Dec\"];\r\nconst sortedMonths = months.toSorted();\r\nconsole.log(sortedMonths); // ['Dec', 'Feb', 'Jan', 'Mar']\r\nconsole.log(months); // ['Mar', 'Jan', 'Feb', 'Dec']\r\n\r\nconst values = [1, 10, 21, 2];\r\nconst sortedValues = values.toSorted((a, b) => a - b);\r\nconsole.log(sortedValues); // [1, 2, 10, 21]\r\nconsole.log(values); // [1, 10, 21, 2]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.toSorted = function(comparefn) {\r\n  // 1. Если comparefn не определен или не является функцией, выбрасываем исключение TypeError\r\n  if (comparefn !== undefined && IsCallable(comparefn) === false) {\r\n    throw new TypeError(\"comparefn must be a callable function or undefined\");\r\n  }\r\n\r\n  // 2. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 3. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 4. Создаем новый массив A длины len\r\n  let A = ArrayCreate(len);\r\n\r\n  // 5. Создаем абстрактное замыкание SortCompare с параметрами (x, y), захватывающее comparefn\r\n  // и выполняющее следующие шаги при вызове:\r\n  //    a. Возвращаем результат сравнения элементов массива x и y с использованием функции comparefn\r\n  let SortCompare = new AbstractClosure((x, y) => CompareArrayElements(x, y, comparefn));\r\n\r\n  // 6. Получаем отсортированный список sortedList с использованием SortIndexedProperties\r\n  let sortedList = SortIndexedProperties(obj, len, SortCompare, READ_THROUGH_HOLES);\r\n\r\n  // 7. Инициализируем счетчик j равным 0\r\n  let j = 0;\r\n\r\n  // 8. Повторяем, пока j < len\r\n  while (j < len) {\r\n    //    a. Создаем свойство A[j] и присваиваем ему значение sortedList[j]\r\n    CreateDataPropertyOrThrow(A, ToString(𝔽(j)), sortedList[j]);\r\n\r\n    //    b. Увеличиваем j на 1\r\n    j = j + 1;\r\n  }\r\n\r\n  // 9. Возвращаем массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. If comparefn is not undefined and IsCallable(comparefn) is false, throw a TypeError exception.\r\n2. Let O be ? ToObject(this value).\r\n3. Let len be ? LengthOfArrayLike(O).\r\n4. Let A be ? ArrayCreate(len).\r\n5. Let SortCompare be a new Abstract Closure with parameters (x, y) that captures comparefn and performs the following steps when called:\r\n  a. Return ? CompareArrayElements(x, y, comparefn).\r\n6. Let sortedList be ? SortIndexedProperties(O, len, SortCompare, READ-THROUGH-HOLES).\r\n7. Let j be 0.\r\n8. Repeat, while j < len,\r\n  a. Perform ! CreateDataPropertyOrThrow(A, ! ToString(𝔽(j)), sortedList[j]).\r\n  b. Set j to j + 1.\r\n9. Return A.\r\n```",
        "parsedMethods": [
          "IsCallable()",
          "TypeError()",
          "ToObject()",
          "LengthOfArrayLike()",
          "ArrayCreate()",
          "AbstractClosure()",
          "CompareArrayElements()",
          "SortIndexedProperties()",
          "CreateDataPropertyOrThrow()",
          "ToString()"
        ],
        "tc": {
          "best": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "average": {
            "title": "O(n log(n))",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n²)",
            "color": "red"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tosorted",
        "title": "toSorted()",
        "slug": "Array/toSorted()"
      },
      "Array/toSpliced()": {
        "content": "Метод `toSpliced()` создает копию исходного массива и изменяет содержимое **копии**, удаляя существующие элементы и/или добавляя новые. Возвращает новый массив.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst months = [\"Jan\", \"Mar\", \"Apr\", \"May\"];\r\n\r\n// Вставляем элемент по индексу 1\r\nconst months2 = months.toSpliced(1, 0, \"Feb\");\r\nconsole.log(months2); // [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"]\r\n\r\n// Удаляем два элемента, начиная с индекса 2\r\nconst months3 = months2.toSpliced(2, 2);\r\nconsole.log(months3); // [\"Jan\", \"Feb\", \"May\"]\r\n\r\n// Заменяем один элемент по индексу 1 двумя новыми\r\nconst months4 = months3.toSpliced(1, 1, \"Feb\", \"Mar\");\r\nconsole.log(months4); // [\"Jan\", \"Feb\", \"Mar\", \"May\"]\r\n\r\n// Оригинальный массив не изменен\r\nconsole.log(months); // [\"Jan\", \"Mar\", \"Apr\", \"May\"]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length + items.length\r\n// k = actualDeleteCount\r\n\r\n// this = arr\r\nArray.prototype.toSpliced = function(start, skipCount, ...items) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем полученный индекс в целое число (или бесконечность)\r\n  let relativeStart = ToIntegerOrInfinity(start);\r\n\r\n  // 4. Если relativeStart = -∞, устанавливаем actualStart = 0\r\n  // 5. Иначе, если relativeStart < 0, устанавливаем actualStart = max(len + relativeStart, 0)\r\n  // 6. Иначе, устанавливаем actualStart = min(relativeStart, len)\r\n  let actualStart = (relativeStart === -Infinity) ? 0 : ((relativeStart < 0) ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len));\r\n\r\n  // 7. Получаем количество элементов в items\r\n  let insertCount = items.length;\r\n\r\n  // 8. Если start отсутствует, устанавливаем actualSkipCount = 0\r\n  // 9. Иначе, если skipCount отсутствует, устанавливаем actualSkipCount = len - actualStart\r\n  // 10. Иначе, устанавливаем actualSkipCount = min(ToIntegerOrInfinity(skipCount), len - actualStart)\r\n  let actualSkipCount = (!start) ? 0 : ((!skipCount) ? len - actualStart : Math.min(ToIntegerOrInfinity(skipCount), len - actualStart));\r\n\r\n  // 11. Вычисляем новую длину массива\r\n  let newLen = len + insertCount - actualSkipCount;\r\n\r\n  // 12. Если новая длина превышает 2^53 - 1, выбрасываем исключение TypeError\r\n  if (newLen > 2**53 - 1) {\r\n    throw new TypeError(\"New length exceeds the maximum array length\");\r\n  }\r\n\r\n  // 13. Создаем новый массив A длиной newLen\r\n  let A = ArrayCreate(newLen);\r\n\r\n  // 14. Инициализируем переменную i\r\n  let i = 0;\r\n\r\n  // 15. Инициализируем переменную r\r\n  let r = actualStart + actualSkipCount;\r\n\r\n  // 16. Копируем элементы до actualStart\r\n  while (i < actualStart) {\r\n    // a. Получаем ключ Pi\r\n    let Pi = !ToString(𝔽(i));\r\n\r\n    // b. Получаем значение iValue по ключу Pi из объекта obj\r\n    let iValue = Get(obj, Pi);\r\n\r\n    // c. Устанавливаем свойство A[Pi] со значением iValue\r\n    CreateDataPropertyOrThrow(A, Pi, iValue);\r\n\r\n    // d. Увеличиваем i на 1\r\n    i++;\r\n  }\r\n\r\n  // 17. Вставляем элементы из items\r\n  for (const E of items) {\r\n    // a. Получаем ключ Pi\r\n    let Pi = !ToString(𝔽(i));\r\n\r\n    // b. Устанавливаем свойство A[Pi] со значением E\r\n    CreateDataPropertyOrThrow(A, Pi, E);\r\n\r\n    // c. Увеличиваем i на 1\r\n    i++;\r\n  }\r\n\r\n  // 18. Копируем оставшиеся элементы после вставки\r\n  while (i < newLen) {\r\n    // a. Получаем ключи Pi и from\r\n    let Pi = !ToString(𝔽(i));\r\n    let from = !ToString(𝔽(r));\r\n\r\n    // b. Получаем значение fromValue по ключу from из объекта obj\r\n    let fromValue = Get(obj, from);\r\n\r\n    // c. Устанавливаем свойство A[Pi] со значением fromValue\r\n    CreateDataPropertyOrThrow(A, Pi, fromValue);\r\n\r\n    // d. Увеличиваем i и r на 1\r\n    i++;\r\n    r++;\r\n  }\r\n\r\n  // 19. Возвращаем новый массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeStart be ? ToIntegerOrInfinity(start).\r\n4. If relativeStart is -∞, let actualStart be 0.\r\n5. Else if relativeStart < 0, let actualStart be max(len + relativeStart, 0).\r\n6. Else, let actualStart be min(relativeStart, len).\r\n7. Let insertCount be the number of elements in items.\r\n8. If start is not present, then\r\n  a. Let actualSkipCount be 0.\r\n9. Else if skipCount is not present, then\r\n  a. Let actualSkipCount be len - actualStart.\r\n10. Else,\r\n  a. Let sc be ? ToIntegerOrInfinity(skipCount).\r\n  b. Let actualSkipCount be the result of clamping sc between 0 and len - actualStart.\r\n11. Let newLen be len + insertCount - actualSkipCount.\r\n12. If newLen > 2**53 - 1, throw a TypeError exception.\r\n13. Let A be ? ArrayCreate(newLen).\r\n14. Let i be 0.\r\n15. Let r be actualStart + actualSkipCount.\r\n16. Repeat, while i < actualStart,\r\n  a. Let Pi be ! ToString(𝔽(i)).\r\n  b. Let iValue be ? Get(O, Pi).\r\n  c. Perform ! CreateDataPropertyOrThrow(A, Pi, iValue).\r\n  d. Set i to i + 1.\r\n17. For each element E of items, do\r\n  a. Let Pi be ! ToString(𝔽(i)).\r\n  b. Perform ! CreateDataPropertyOrThrow(A, Pi, E).\r\n  c. Set i to i + 1.\r\n18. Repeat, while i < newLen,\r\n  a. Let Pi be ! ToString(𝔽(i)).\r\n  b. Let from be ! ToString(𝔽(r)).\r\n  c. Let fromValue be ? Get(O, from).\r\n  d. Perform ! CreateDataPropertyOrThrow(A, Pi, fromValue).\r\n  e. Set i to i + 1.\r\n  f. Set r to r + 1.\r\n19. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "TypeError()",
          "ArrayCreate()",
          "ToString()",
          "Get()",
          "CreateDataPropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n - k)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tospliced",
        "title": "toSpliced()",
        "slug": "Array/toSpliced()"
      },
      "Array/toString()": {
        "content": "Метод `toString()` возвращает строковое представление указанного массива и его элементов.\r\n\r\nМетод `toString()` вызывает метод `join()`, не передавая параметр `separator` (в `join()` по умолчанию равен `,`).\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2, 'a', '1a'];\r\n\r\nconsole.log(arr.toString());\r\n// \"1,2,a,1a\"\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = R.length (результирующая строка)\r\n\r\n// this = arr\r\nArray.prototype.toString = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let array = ToObject(this);\r\n\r\n  // 2. Получаем метод \"join\" объекта array\r\n  let func = Get(array, \"join\");\r\n\r\n  // 3. Если func не является вызываемой функцией,\r\n  // устанавливаем func во встроенную функцию %Object.prototype.toString%\r\n  if (!IsCallable(func)) {\r\n    func = %Object.prototype.toString%;\r\n  }\r\n\r\n  // 4. Возвращаем результат вызова функции func на объекте array\r\n  return Call(func, array);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let array be ? ToObject(this value).\r\n2. Let func be ? Get(array, \"join\").\r\n3. If IsCallable(func) is false, set func to the intrinsic function %Object.prototype.toString%.\r\n4. Return ? Call(func, array).\r\n```",
        "parsedMethods": [
          "ToObject()",
          "Get()",
          "IsCallable()",
          "Call()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.tostring",
        "title": "toString()",
        "slug": "Array/toString()"
      },
      "Array/unshift()": {
        "content": "Метод `unshift()` добавляет один или более элементов в начало массива и возвращает **новую длину** массива.\r\n\r\nКогда мы используем `unshift()` для добавления нескольких элементов в начало массива, это может занять дополнительную память. Если текущая длина массива не достаточна для хранения всех новых элементов, то может потребоваться выделение дополнительной памяти.\r\n\r\nВ большинстве современных движков JavaScript такие операции управления памятью автоматизированы, и они заботятся о расширении массива и выделении необходимой памяти. Как следствие, сложность по памяти для метода `unshift()` остается амортизированной `O(1)` в среднем случае, но иногда может возникнуть необходимость в выделении дополнительной памяти, что приведет к временным затратам.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2];\r\n\r\narr.unshift(0); // = 3\r\n// [0, 1, 2]\r\n\r\narr.unshift(-2, -1); // = 5\r\n// [-2, -1, 0, 1, 2]\r\n\r\narr.unshift([-3]); // = 6\r\n// [[-3], -2, -1, 0, 1, 2]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.unshift = function(...items) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Получаем количество элементов в массиве items\r\n  let argCount = items.length;\r\n\r\n  // 4. Если argCount > 0, выполняем следующие шаги\r\n  if (argCount > 0) {\r\n    // a. Если len + argCount > 2**53 - 1, выбрасываем исключение TypeError\r\n    if (len + argCount > 2**53 - 1) {\r\n      throw new TypeError();\r\n    }\r\n\r\n    // b. Устанавливаем начальное значение для индекса k\r\n    let k = len;\r\n\r\n    // c. Повторяем, пока k > 0\r\n    while (k > 0) {\r\n      // i. Получаем строковые представления индексов from и to\r\n      let from = ToString(𝔽(k - 1));\r\n      let to = ToString(𝔽(k + argCount - 1));\r\n\r\n      // ii. Проверяем, есть ли свойство с индексом from\r\n      let fromPresent = HasProperty(obj, from);\r\n\r\n      // iii. Если свойство с индексом from существует\r\n      if (fromPresent) {\r\n        // 1. Получаем значение свойства from\r\n        let fromValue = Get(obj, from);\r\n        // 2. Устанавливаем значение свойства to равным fromValue\r\n        Set(obj, to, fromValue, true);\r\n      } else {\r\n        // 1. Если свойства с индексом from нет, удаляем свойство to\r\n        DeletePropertyOrThrow(obj, to);\r\n      }\r\n\r\n      // iv. Уменьшаем значение k\r\n      k = k - 1;\r\n    }\r\n\r\n    // d. Устанавливаем начальное значение для индекса j\r\n    let j = +0𝔽;\r\n\r\n    // e. Для каждого элемента E массива items выполняем следующие шаги\r\n    for (let E of items) {\r\n      // i. Устанавливаем свойство с индексом j равным E\r\n      Set(obj, ToString(j), E, true);\r\n      // ii. Увеличиваем значение j\r\n      j = j + 1𝔽;\r\n    }\r\n  }\r\n\r\n  // 5. Устанавливаем новую длину массива (len + argCount)\r\n  Set(obj, \"length\", 𝔽(len + argCount), true);\r\n\r\n  // 6. Возвращаем новую длину массива\r\n  return 𝔽(len + argCount);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let argCount be the number of elements in items.\r\n4. If argCount > 0, then\r\n  a. If len + argCount > 2**53 - 1, throw a TypeError exception.\r\n  b. Let k be len.\r\n  c. Repeat, while k > 0,\r\n    i. Let from be ! ToString(𝔽(k - 1)).\r\n    ii. Let to be ! ToString(𝔽(k + argCount - 1)).\r\n    iii. Let fromPresent be ? HasProperty(O, from).\r\n    iv. If fromPresent is true, then\r\n      1. Let fromValue be ? Get(O, from).\r\n      2. Perform ? Set(O, to, fromValue, true).\r\n    v. Else,\r\n      1. Assert: fromPresent is false.\r\n      2. Perform ? DeletePropertyOrThrow(O, to).\r\n    vi. Set k to k - 1.\r\n  d. Let j be +0𝔽.\r\n  e. For each element E of items, do\r\n    i. Perform ? Set(O, ! ToString(j), E, true).\r\n    ii. Set j to j + 1𝔽.\r\n5. Perform ? Set(O, \"length\", 𝔽(len + argCount), true).\r\n6. Return 𝔽(len + argCount).\r\n```",
        "parsedMethods": [
          "O()",
          "ToObject()",
          "LengthOfArrayLike()",
          "TypeError()",
          "ToString()",
          "HasProperty()",
          "Get()",
          "Set()",
          "DeletePropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.unshift",
        "title": "unshift()",
        "slug": "Array/unshift()"
      },
      "Array/values()": {
        "content": "Метод `values()` возвращает новый объект итератора массива `Array Iterator`, содержащий значения для каждого индекса в массиве.\r\n\r\n##### Использование\r\n\r\n```js\r\n// 1.\r\nconst arr = [\"w\", \"y\", \"k\", \"o\", \"p\"];\r\nconst eArr = arr.values();\r\n\r\nfor (let letter of eArr) {\r\n  console.log(letter);\r\n}\r\n\r\n// или\r\n\r\nconsole.log(eArr.next().value);\r\nconsole.log(eArr.next().value);\r\nconsole.log(eArr.next().value);\r\nconsole.log(eArr.next().value);\r\nconsole.log(eArr.next().value);\r\n\r\n// w\r\n// y\r\n// k\r\n// o\r\n// p\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// n = arr.length\r\n\r\n// this = arr\r\nArray.prototype.values = function() {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Создаем и возвращаем новый объект итератора для массива obj. \r\n  // Итератор будет возвращать значение для каждого \r\n  // элемента в массиве. Параметр value указывает, что итератор \r\n  // должен возвращать только значение для каждого элемента.\r\n  return CreateArrayIterator(obj, value);\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Return CreateArrayIterator(O, VALUE).\r\n```",
        "parsedMethods": [
          "ToObject()",
          "CreateArrayIterator()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(1)",
          "color": "green"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.values",
        "title": "values()",
        "slug": "Array/values()"
      },
      "Array/with()": {
        "content": "Метод `with()` является аналогом использования скобочной нотации для изменения значения в массиве по индексу. Он возвращает **новый массив**, в котором элемент по заданному индексу заменен заданным значением.\r\n\r\n##### Использование\r\n\r\n```js\r\nconst arr = [1, 2, 3, 4, 5];\r\nconsole.log(arr.with(2, 6)); // [1, 2, 6, 4, 5]\r\nconsole.log(arr); // [1, 2, 3, 4, 5]\r\n```\r\n\r\n##### Примерная внутренняя реализация\r\n\r\n```js\r\n// this = arr\r\nArray.prototype.with = function(index, value) {\r\n  // 1. Преобразуем this в объект, если это необходимо\r\n  let obj = ToObject(this);\r\n\r\n  // 2. Получаем длину массивоподобного объекта obj\r\n  let len = LengthOfArrayLike(obj);\r\n\r\n  // 3. Преобразуем полученный индекс в целое число (или бесконечность)\r\n  let relativeIndex = ToIntegerOrInfinity(index);\r\n\r\n  // 4. Если relativeIndex >= 0, устанавливаем actualIndex = relativeIndex\r\n  // 5. Иначе устанавливаем actualIndex = len + relativeIndex\r\n  let actualIndex = (relativeIndex >= 0) ? relativeIndex : (len + relativeIndex);\r\n\r\n  // 6. Если actualIndex выходит за пределы arr, выбрасываем исключение RangeError\r\n  if (actualIndex >= len || actualIndex < 0) {\r\n    throw new RangeError(\"Index out of range\");\r\n  }\r\n\r\n  // 7. Создаем новый массив A длиной len\r\n  let A = ArrayCreate(len);\r\n\r\n  // 8. Устанавливаем начальное значение k = 0\r\n  let k = 0;\r\n\r\n  // 9. Повторяем, пока k < len\r\n  while (k < len) {\r\n    // a. Получаем строковый ключ Pk для текущего индекса k\r\n    let Pk = ToString(𝔽(k));\r\n\r\n    // b. Если k равен actualIndex, устанавливаем fromValue равным переданному значению value\r\n    // c. Иначе устанавливаем fromValue равным значению, полученному из объекта obj по ключу Pk\r\n    let fromValue = (k === actualIndex) ? value : Get(obj, Pk);\r\n\r\n    // d. Устанавливаем свойство с ключом Pk в массиве A со значением fromValue\r\n    CreateDataPropertyOrThrow(A, Pk, fromValue);\r\n\r\n    // e. Увеличиваем k на 1\r\n    k = k + 1;\r\n  }\r\n\r\n  // 10. Возвращаем созданный массив A\r\n  return A;\r\n};\r\n```\r\n\r\n##### ECMAScript\r\n\r\n```js\r\n1. Let O be ? ToObject(this value).\r\n2. Let len be ? LengthOfArrayLike(O).\r\n3. Let relativeIndex be ? ToIntegerOrInfinity(index).\r\n4. If relativeIndex ≥ 0, let actualIndex be relativeIndex.\r\n5. Else, let actualIndex be len + relativeIndex.\r\n6. If actualIndex ≥ len or actualIndex < 0, throw a RangeError exception.\r\n7. Let A be ? ArrayCreate(len).\r\n8. Let k be 0.\r\n9. Repeat, while k < len,\r\n  a. Let Pk be ! ToString(𝔽(k)).\r\n  b. If k is actualIndex, let fromValue be value.\r\n  c. Else, let fromValue be ? Get(O, Pk).\r\n  d. Perform ! CreateDataPropertyOrThrow(A, Pk, fromValue).\r\n  e. Set k to k + 1.\r\n10. Return A.\r\n```",
        "parsedMethods": [
          "ToObject()",
          "LengthOfArrayLike()",
          "ToIntegerOrInfinity()",
          "RangeError()",
          "ArrayCreate()",
          "ToString()",
          "Get()",
          "CreateDataPropertyOrThrow()"
        ],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n)",
            "color": "lightgreen"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.with",
        "title": "with()",
        "slug": "Array/with()"
      }
    },
    "ECMAScript": {
      "ECMAScript/ToString()": {
        "content": "",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n)",
            "color": "lightgreen"
          },
          "worst": {
            "title": "O(n * k)",
            "color": "orange"
          }
        },
        "sc": {
          "title": "O(n)",
          "color": "lightgreen"
        },
        "esLink": "https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.from",
        "title": "ToString()",
        "slug": "ECMAScript/ToString()"
      }
    },
    "String": {
      "String/anchor()": {
        "content": "`anchor`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "anchor()",
        "slug": "String/anchor()"
      },
      "String/at()": {
        "content": "`at`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "at()",
        "slug": "String/at()"
      },
      "String/big()": {
        "content": "`big`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "big()",
        "slug": "String/big()"
      },
      "String/blink()": {
        "content": "`blink`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "blink()",
        "slug": "String/blink()"
      },
      "String/bold()": {
        "content": "`bold`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "bold()",
        "slug": "String/bold()"
      },
      "String/charAt()": {
        "content": "`charAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "charAt()",
        "slug": "String/charAt()"
      },
      "String/charCodeAt()": {
        "content": "`charCodeAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "charCodeAt()",
        "slug": "String/charCodeAt()"
      },
      "String/codePointAt()": {
        "content": "`codePointAt`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "codePointAt()",
        "slug": "String/codePointAt()"
      },
      "String/concat()": {
        "content": "`concat`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "concat()",
        "slug": "String/concat()"
      },
      "String/endsWith()": {
        "content": "`endsWith`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "endsWith()",
        "slug": "String/endsWith()"
      },
      "String/fixed()": {
        "content": "`fixed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fixed()",
        "slug": "String/fixed()"
      },
      "String/fontcolor()": {
        "content": "`fontcolor`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fontcolor()",
        "slug": "String/fontcolor()"
      },
      "String/fontsize()": {
        "content": "`fontsize`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "fontsize()",
        "slug": "String/fontsize()"
      },
      "String/includes()": {
        "content": "`includes`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "includes()",
        "slug": "String/includes()"
      },
      "String/indexOf()": {
        "content": "`indexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "indexOf()",
        "slug": "String/indexOf()"
      },
      "String/isWellFormed()": {
        "content": "`isWellFormed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "isWellFormed()",
        "slug": "String/isWellFormed()"
      },
      "String/italics()": {
        "content": "`italics`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "italics()",
        "slug": "String/italics()"
      },
      "String/lastIndexOf()": {
        "content": "`lastIndexOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "lastIndexOf()",
        "slug": "String/lastIndexOf()"
      },
      "String/link()": {
        "content": "`link`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "link()",
        "slug": "String/link()"
      },
      "String/localeCompare()": {
        "content": "`localeCompare`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "localeCompare()",
        "slug": "String/localeCompare()"
      },
      "String/match()": {
        "content": "`match`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "match()",
        "slug": "String/match()"
      },
      "String/matchAll()": {
        "content": "`matchAll`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "matchAll()",
        "slug": "String/matchAll()"
      },
      "String/normalize()": {
        "content": "`normalize`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "normalize()",
        "slug": "String/normalize()"
      },
      "String/padEnd()": {
        "content": "`padEnd`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "padEnd()",
        "slug": "String/padEnd()"
      },
      "String/padStart()": {
        "content": "`padStart`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "padStart()",
        "slug": "String/padStart()"
      },
      "String/repeat()": {
        "content": "`repeat`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "repeat()",
        "slug": "String/repeat()"
      },
      "String/replace()": {
        "content": "`replace`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "replace()",
        "slug": "String/replace()"
      },
      "String/replaceAll()": {
        "content": "`replaceAll`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "replaceAll()",
        "slug": "String/replaceAll()"
      },
      "String/search()": {
        "content": "`search`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "search()",
        "slug": "String/search()"
      },
      "String/slice()": {
        "content": "Привет :) Это метод `slice`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "slice()",
        "slug": "String/slice()"
      },
      "String/small()": {
        "content": "`small`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "small()",
        "slug": "String/small()"
      },
      "String/split()": {
        "content": "Привет :) Это метод `split`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "split()",
        "slug": "String/split()"
      },
      "String/startsWith()": {
        "content": "`startsWith`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "startsWith()",
        "slug": "String/startsWith()"
      },
      "String/strike()": {
        "content": "`strike`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "strike()",
        "slug": "String/strike()"
      },
      "String/String.fromCharCode()": {
        "content": "`String.fromCharCode`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.fromCharCode()",
        "slug": "String/String.fromCharCode()"
      },
      "String/String.fromCodePoint()": {
        "content": "`String.fromCodePoint`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.fromCodePoint()",
        "slug": "String/String.fromCodePoint()"
      },
      "String/String.raw()": {
        "content": "`String.raw`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "String.raw()",
        "slug": "String/String.raw()"
      },
      "String/sub()": {
        "content": "`sub`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "sub()",
        "slug": "String/sub()"
      },
      "String/substr()": {
        "content": "`substr`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "substr()",
        "slug": "String/substr()"
      },
      "String/substring()": {
        "content": "`substring`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "substring()",
        "slug": "String/substring()"
      },
      "String/sup()": {
        "content": "`sup`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "sup()",
        "slug": "String/sup()"
      },
      "String/toLocaleLowerCase()": {
        "content": "`toLocaleLowerCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLocaleLowerCase()",
        "slug": "String/toLocaleLowerCase()"
      },
      "String/toLocaleUpperCase()": {
        "content": "`toLocaleUpperCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLocaleUpperCase()",
        "slug": "String/toLocaleUpperCase()"
      },
      "String/toLowerCase()": {
        "content": "`toLowerCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toLowerCase()",
        "slug": "String/toLowerCase()"
      },
      "String/toString()": {
        "content": "`toString`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toString()",
        "slug": "String/toString()"
      },
      "String/toUpperCase()": {
        "content": "`toUpperCase`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toUpperCase()",
        "slug": "String/toUpperCase()"
      },
      "String/toWellFormed()": {
        "content": "`toWellFormed`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "toWellFormed()",
        "slug": "String/toWellFormed()"
      },
      "String/trim()": {
        "content": "`trim`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trim()",
        "slug": "String/trim()"
      },
      "String/trimEnd()": {
        "content": "`trimEnd`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trimEnd()",
        "slug": "String/trimEnd()"
      },
      "String/trimStart()": {
        "content": "`trimStart`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "trimStart()",
        "slug": "String/trimStart()"
      },
      "String/valueOf": {
        "content": "`valueOf`.",
        "parsedMethods": [],
        "tc": {
          "best": {
            "title": "O(n + m)",
            "color": "lightgreen"
          },
          "average": {
            "title": "O(n + m)",
            "color": "limegreen"
          },
          "worst": {
            "title": "O(n * m)",
            "color": "limegreen"
          }
        },
        "sc": {
          "title": "O(n * m)",
          "color": "limegreen"
        },
        "esLink": "",
        "title": "valueOf",
        "slug": "String/valueOf"
      }
    }
  }
}